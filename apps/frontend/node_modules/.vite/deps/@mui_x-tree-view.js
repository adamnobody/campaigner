import {
  Alert_default,
  Checkbox_default,
  CircularProgress_default,
  Collapse_default,
  Typography_default,
  extractEventHandlers_default,
  resolveComponentProps_default,
  useLazyRef,
  useOnMount,
  useSlotProps_default
} from "./chunk-4ZGS7TM5.js";
import {
  useThemeProps
} from "./chunk-OICDGDSD.js";
import "./chunk-YU64HH5L.js";
import {
  _objectWithoutPropertiesLoose
} from "./chunk-QPIZBQM2.js";
import {
  createSvgIcon,
  unsupportedProp
} from "./chunk-YD6KHH5A.js";
import {
  alpha,
  clsx_default,
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  require_prop_types,
  shouldForwardProp,
  styled_default,
  useRtl
} from "./chunk-MR4PQQJG.js";
import {
  _extends
} from "./chunk-VMQKBCTX.js";
import {
  require_jsx_runtime
} from "./chunk-6ZBINRVT.js";
import {
  require_react
} from "./chunk-L67IFW26.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is2(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React35.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState5({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect3(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect9(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React35 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is2, useState5 = React35.useState, useEffect9 = React35.useEffect, useLayoutEffect3 = React35.useLayoutEffect, useDebugValue = React35.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React35.useSyncExternalStore ? React35.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../../node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "../../node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is2(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React35 = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore2 = shim.useSyncExternalStore, useRef13 = React35.useRef, useEffect9 = React35.useEffect, useMemo9 = React35.useMemo, useDebugValue = React35.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef13(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo9(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
        useEffect9(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../../node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "../../node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// ../../node_modules/@mui/x-tree-view/esm/SimpleTreeView/SimpleTreeView.js
var React24 = __toESM(require_react(), 1);
var import_prop_types2 = __toESM(require_prop_types(), 1);

// ../../node_modules/@mui/x-internals/esm/warning/warning.js
var warnedOnceCache = /* @__PURE__ */ new Set();
function warnOnce(message, gravity = "warning") {
  if (false) {
    return;
  }
  const cleanMessage = Array.isArray(message) ? message.join("\n") : message;
  if (!warnedOnceCache.has(cleanMessage)) {
    warnedOnceCache.add(cleanMessage);
    if (gravity === "error") {
      console.error(cleanMessage);
    } else {
      console.warn(cleanMessage);
    }
  }
}

// ../../node_modules/@mui/x-tree-view/esm/internals/zero-styled/index.js
function createUseThemeProps(name) {
  return useThemeProps;
}

// ../../node_modules/@mui/x-tree-view/esm/SimpleTreeView/simpleTreeViewClasses.js
function getSimpleTreeViewUtilityClass(slot) {
  return generateUtilityClass("MuiSimpleTreeView", slot);
}
var simpleTreeViewClasses = generateUtilityClasses("MuiSimpleTreeView", ["root", "item", "itemContent", "itemGroupTransition", "itemIconContainer", "itemLabel", "itemCheckbox"]);

// ../../node_modules/@mui/x-tree-view/esm/internals/useTreeView/useTreeView.js
var React8 = __toESM(require_react(), 1);

// ../../node_modules/@base-ui/utils/esm/useRefWithInit.js
var React = __toESM(require_react());
var UNINITIALIZED = {};
function useRefWithInit(init, initArg) {
  const ref = React.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init(initArg);
  }
  return ref;
}

// ../../node_modules/reselect/dist/reselect.mjs
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
    let isInputSameAsOutput = false;
    try {
      const emptyObject = {};
      if (resultFunc(emptyObject) === emptyObject)
        isInputSameAsOutput = true;
    } catch {
    }
    if (isInputSameAsOutput) {
      let stack = void 0;
      try {
        throw new Error();
      } catch (e) {
        ;
        ({ stack } = e);
      }
      console.warn(
        "The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",
        { stack }
      );
    }
  }
};
var runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs) => {
  const { memoize, memoizeOptions } = options;
  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions);
  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
  if (!areInputSelectorResultsEqual) {
    let stack = void 0;
    try {
      throw new Error();
    } catch (e) {
      ;
      ({ stack } = e);
    }
    console.warn(
      "An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",
      {
        arguments: inputSelectorArgs,
        firstInputs: inputSelectorResults,
        secondInputs: inputSelectorResultsCopy,
        stack
      }
    );
  }
};
var globalDevModeChecks = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
var NOT_FOUND = /* @__PURE__ */ Symbol("NOT_FOUND");
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
  if (typeof object !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array.every((item) => typeof item === "function")) {
    const itemTypes = array.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length } = dependencies;
  for (let i = 0; i < length; i++) {
    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
  const { identityFunctionCheck, inputStabilityCheck } = {
    ...globalDevModeChecks,
    ...devModeChecks
  };
  return {
    identityFunctionCheck: {
      shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
      run: runIdentityFunctionCheck
    },
    inputStabilityCheck: {
      shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
      run: runInputStabilityCheck
    }
  };
};
var proto = Object.getPrototypeOf({});
function createSingletonCache(equals) {
  let entry;
  return {
    get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put(key, value) {
      entry = { key, value };
    },
    getEntries() {
      return entry ? [entry] : [];
    },
    clear() {
      entry = void 0;
    }
  };
}
function createLruCache(maxSize, equals) {
  let entries = [];
  function get(key) {
    const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));
    if (cacheIndex > -1) {
      const entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      entries.unshift({ key, value });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  function getEntries() {
    return entries;
  }
  function clear() {
    entries = [];
  }
  return { get, put, getEntries, clear };
}
var referenceEqualityCheck = (a, b) => a === b;
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
      return false;
    }
    const { length } = prev;
    for (let i = 0; i < length; i++) {
      if (!equalityCheck(prev[i], next[i])) {
        return false;
      }
    }
    return true;
  };
}
function lruMemoize(func, equalityCheckOrOptions) {
  const providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions };
  const {
    equalityCheck = referenceEqualityCheck,
    maxSize = 1,
    resultEqualityCheck
  } = providedOptions;
  const comparator = createCacheKeyComparator(equalityCheck);
  let resultsCount = 0;
  const cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    let value = cache.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const entries = cache.getEntries();
        const matchingEntry = entries.find(
          (entry) => resultEqualityCheck(entry.value, value)
        );
        if (matchingEntry) {
          value = matchingEntry.value;
          resultsCount !== 0 && resultsCount--;
        }
      }
      cache.put(arguments, value);
    }
    return value;
  }
  memoized.clearCache = () => {
    cache.clear();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    let cacheNode = fnNode;
    const { length } = arguments;
    for (let i = 0, l = length; i < l; i++) {
      const arg = arguments[i];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = lastResult?.deref?.() ?? lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector22 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    let firstRun = true;
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      if (true) {
        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
        if (identityFunctionCheck.shouldRun) {
          identityFunctionCheck.run(
            resultFunc,
            inputSelectorResults,
            lastResult
          );
        }
        if (inputStabilityCheck.shouldRun) {
          const inputSelectorResultsCopy = collectInputSelectorResults(
            dependencies,
            arguments
          );
          inputStabilityCheck.run(
            { inputSelectorResults, inputSelectorResultsCopy },
            { memoize, memoizeOptions: finalMemoizeOptions },
            arguments
          );
        }
        if (firstRun)
          firstRun = false;
      }
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize,
      argsMemoize
    });
  };
  Object.assign(createSelector22, {
    withTypes: () => createSelector22
  });
  return createSelector22;
}
var createSelector = createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index) => {
          composition[inputSelectorKeys[index]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);

// ../../node_modules/@mui/x-internals/esm/store/createSelector.js
var reselectCreateSelector = createSelectorCreator({
  memoize: lruMemoize,
  memoizeOptions: {
    maxSize: 1,
    equalityCheck: Object.is
  }
});
var createSelector2 = (a, b, c, d, e, f, g, h, ...other) => {
  if (other.length > 0) {
    throw new Error("Unsupported number of selectors");
  }
  let selector;
  if (a && b && c && d && e && f && g && h) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      const vc = c(state, a1, a2, a3);
      const vd = d(state, a1, a2, a3);
      const ve = e(state, a1, a2, a3);
      const vf = f(state, a1, a2, a3);
      const vg = g(state, a1, a2, a3);
      return h(va, vb, vc, vd, ve, vf, vg, a1, a2, a3);
    };
  } else if (a && b && c && d && e && f && g) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      const vc = c(state, a1, a2, a3);
      const vd = d(state, a1, a2, a3);
      const ve = e(state, a1, a2, a3);
      const vf = f(state, a1, a2, a3);
      return g(va, vb, vc, vd, ve, vf, a1, a2, a3);
    };
  } else if (a && b && c && d && e && f) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      const vc = c(state, a1, a2, a3);
      const vd = d(state, a1, a2, a3);
      const ve = e(state, a1, a2, a3);
      return f(va, vb, vc, vd, ve, a1, a2, a3);
    };
  } else if (a && b && c && d && e) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      const vc = c(state, a1, a2, a3);
      const vd = d(state, a1, a2, a3);
      return e(va, vb, vc, vd, a1, a2, a3);
    };
  } else if (a && b && c && d) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      const vc = c(state, a1, a2, a3);
      return d(va, vb, vc, a1, a2, a3);
    };
  } else if (a && b && c) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      return c(va, vb, a1, a2, a3);
    };
  } else if (a && b) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      return b(va, a1, a2, a3);
    };
  } else if (a) {
    selector = a;
  } else {
    throw new Error("Missing arguments");
  }
  return selector;
};
var createSelectorMemoizedWithOptions = (options) => (...inputs) => {
  const cache = /* @__PURE__ */ new WeakMap();
  let nextCacheId = 1;
  const combiner = inputs[inputs.length - 1];
  const nSelectors = inputs.length - 1 || 1;
  const argsLength = Math.max(combiner.length - nSelectors, 0);
  if (argsLength > 3) {
    throw new Error("Unsupported number of arguments");
  }
  const selector = (state, a1, a2, a3) => {
    let cacheKey = state.__cacheKey__;
    if (!cacheKey) {
      cacheKey = {
        id: nextCacheId
      };
      state.__cacheKey__ = cacheKey;
      nextCacheId += 1;
    }
    let fn = cache.get(cacheKey);
    if (!fn) {
      const selectors = inputs.length === 1 ? [(x) => x, combiner] : inputs;
      let reselectArgs = inputs;
      const selectorArgs = [void 0, void 0, void 0];
      switch (argsLength) {
        case 0:
          break;
        case 1: {
          reselectArgs = [...selectors.slice(0, -1), () => selectorArgs[0], combiner];
          break;
        }
        case 2: {
          reselectArgs = [...selectors.slice(0, -1), () => selectorArgs[0], () => selectorArgs[1], combiner];
          break;
        }
        case 3: {
          reselectArgs = [...selectors.slice(0, -1), () => selectorArgs[0], () => selectorArgs[1], () => selectorArgs[2], combiner];
          break;
        }
        default:
          throw new Error("Unsupported number of arguments");
      }
      if (options) {
        reselectArgs = [...reselectArgs, options];
      }
      fn = reselectCreateSelector(...reselectArgs);
      fn.selectorArgs = selectorArgs;
      cache.set(cacheKey, fn);
    }
    switch (argsLength) {
      case 3:
        fn.selectorArgs[2] = a3;
      case 2:
        fn.selectorArgs[1] = a2;
      case 1:
        fn.selectorArgs[0] = a1;
      case 0:
      default:
    }
    switch (argsLength) {
      case 0:
        return fn(state);
      case 1:
        return fn(state, a1);
      case 2:
        return fn(state, a1, a2);
      case 3:
        return fn(state, a1, a2, a3);
      default:
        throw new Error("unreachable");
    }
  };
  return selector;
};
var createSelectorMemoized = createSelectorMemoizedWithOptions();

// ../../node_modules/@mui/x-internals/esm/store/useStore.js
var React3 = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);

// ../../node_modules/@mui/x-internals/esm/reactMajor/index.js
var React2 = __toESM(require_react(), 1);
var reactMajor_default = parseInt(React2.version, 10);

// ../../node_modules/@mui/x-internals/esm/store/useStore.js
var canUseRawUseSyncExternalStore = reactMajor_default >= 19;
var useStoreImplementation = canUseRawUseSyncExternalStore ? useStoreR19 : useStoreLegacy;
function useStore(store, selector, a1, a2, a3) {
  return useStoreImplementation(store, selector, a1, a2, a3);
}
function useStoreR19(store, selector, a1, a2, a3) {
  const getSelection = React3.useCallback(() => selector(store.getSnapshot(), a1, a2, a3), [store, selector, a1, a2, a3]);
  return (0, import_shim.useSyncExternalStore)(store.subscribe, getSelection, getSelection);
}
function useStoreLegacy(store, selector, a1, a2, a3) {
  return (0, import_with_selector.useSyncExternalStoreWithSelector)(store.subscribe, store.getSnapshot, store.getSnapshot, (state) => selector(state, a1, a2, a3));
}

// ../../node_modules/@mui/x-internals/esm/store/useStoreEffect.js
var noop = () => {
};
function useStoreEffect(store, selector, effect) {
  const instance = useLazyRef(initialize, {
    store,
    selector
  }).current;
  instance.effect = effect;
  useOnMount(instance.onMount);
}
function initialize(params) {
  const {
    store,
    selector
  } = params;
  let previousState = selector(store.state);
  const instance = {
    effect: noop,
    dispose: null,
    // We want a single subscription done right away and cleared on unmount only,
    // but React triggers `useOnMount` multiple times in dev, so we need to manage
    // the subscription anyway.
    subscribe: () => {
      instance.dispose ??= store.subscribe((state) => {
        const nextState = selector(state);
        if (!Object.is(previousState, nextState)) {
          const prev = previousState;
          previousState = nextState;
          instance.effect(prev, nextState);
        }
      });
    },
    onMount: () => {
      instance.subscribe();
      return () => {
        instance.dispose?.();
        instance.dispose = null;
      };
    }
  };
  instance.subscribe();
  return instance;
}

// ../../node_modules/@mui/x-internals/esm/store/Store.js
var Store = class _Store {
  // HACK: `any` fixes adding listeners that accept partial state.
  // Internal state to handle recursive `setState()` calls
  static create(state) {
    return new _Store(state);
  }
  constructor(state) {
    this.state = state;
    this.listeners = /* @__PURE__ */ new Set();
    this.updateTick = 0;
  }
  subscribe = (fn) => {
    this.listeners.add(fn);
    return () => {
      this.listeners.delete(fn);
    };
  };
  /**
   * Returns the current state snapshot. Meant for usage with `useSyncExternalStore`.
   * If you want to access the state, use the `state` property instead.
   */
  getSnapshot = () => {
    return this.state;
  };
  setState(newState) {
    this.state = newState;
    this.updateTick += 1;
    const currentTick = this.updateTick;
    const it = this.listeners.values();
    let result;
    while (result = it.next(), !result.done) {
      if (currentTick !== this.updateTick) {
        return;
      }
      const listener = result.value;
      listener(newState);
    }
  }
  update(changes) {
    for (const key in changes) {
      if (!Object.is(this.state[key], changes[key])) {
        this.setState(_extends({}, this.state, changes));
        return;
      }
    }
  }
  set(key, value) {
    if (!Object.is(this.state[key], value)) {
      this.setState(_extends({}, this.state, {
        [key]: value
      }));
    }
  }
  use = /* @__PURE__ */ (() => (selector, a1, a2, a3) => {
    return useStore(this, selector, a1, a2, a3);
  })();
};

// ../../node_modules/@base-ui/utils/esm/useMergedRefs.js
function useMergedRefs(a, b, c, d) {
  const forkRef = useRefWithInit(createForkRef).current;
  if (didChange(forkRef, a, b, c, d)) {
    update(forkRef, [a, b, c, d]);
  }
  return forkRef.callback;
}
function createForkRef() {
  return {
    callback: null,
    cleanup: null,
    refs: []
  };
}
function didChange(forkRef, a, b, c, d) {
  return forkRef.refs[0] !== a || forkRef.refs[1] !== b || forkRef.refs[2] !== c || forkRef.refs[3] !== d;
}
function update(forkRef, refs) {
  forkRef.refs = refs;
  if (refs.every((ref) => ref == null)) {
    forkRef.callback = null;
    return;
  }
  forkRef.callback = (instance) => {
    if (forkRef.cleanup) {
      forkRef.cleanup();
      forkRef.cleanup = null;
    }
    if (instance != null) {
      const cleanupCallbacks = Array(refs.length).fill(null);
      for (let i = 0; i < refs.length; i += 1) {
        const ref = refs[i];
        if (ref == null) {
          continue;
        }
        switch (typeof ref) {
          case "function": {
            const refCleanup = ref(instance);
            if (typeof refCleanup === "function") {
              cleanupCallbacks[i] = refCleanup;
            }
            break;
          }
          case "object": {
            ref.current = instance;
            break;
          }
          default:
        }
      }
      forkRef.cleanup = () => {
        for (let i = 0; i < refs.length; i += 1) {
          const ref = refs[i];
          if (ref == null) {
            continue;
          }
          switch (typeof ref) {
            case "function": {
              const cleanupCallback = cleanupCallbacks[i];
              if (typeof cleanupCallback === "function") {
                cleanupCallback();
              } else {
                ref(null);
              }
              break;
            }
            case "object": {
              ref.current = null;
              break;
            }
            default:
          }
        }
      };
    }
  };
}

// ../../node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewInstanceEvents/useTreeViewInstanceEvents.js
var React4 = __toESM(require_react(), 1);

// ../../node_modules/@mui/x-internals/esm/EventManager/EventManager.js
var EventManager = class {
  maxListeners = 20;
  warnOnce = false;
  events = {};
  on(eventName, listener, options = {}) {
    let collection = this.events[eventName];
    if (!collection) {
      collection = {
        highPriority: /* @__PURE__ */ new Map(),
        regular: /* @__PURE__ */ new Map()
      };
      this.events[eventName] = collection;
    }
    if (options.isFirst) {
      collection.highPriority.set(listener, true);
    } else {
      collection.regular.set(listener, true);
    }
    if (true) {
      const collectionSize = collection.highPriority.size + collection.regular.size;
      if (collectionSize > this.maxListeners && !this.warnOnce) {
        this.warnOnce = true;
        console.warn([`Possible EventEmitter memory leak detected. ${collectionSize} ${eventName} listeners added.`].join("\n"));
      }
    }
  }
  removeListener(eventName, listener) {
    if (this.events[eventName]) {
      this.events[eventName].regular.delete(listener);
      this.events[eventName].highPriority.delete(listener);
    }
  }
  removeAllListeners() {
    this.events = {};
  }
  emit(eventName, ...args) {
    const collection = this.events[eventName];
    if (!collection) {
      return;
    }
    const highPriorityListeners = Array.from(collection.highPriority.keys());
    const regularListeners = Array.from(collection.regular.keys());
    for (let i = highPriorityListeners.length - 1; i >= 0; i -= 1) {
      const listener = highPriorityListeners[i];
      if (collection.highPriority.has(listener)) {
        listener.apply(this, args);
      }
    }
    for (let i = 0; i < regularListeners.length; i += 1) {
      const listener = regularListeners[i];
      if (collection.regular.has(listener)) {
        listener.apply(this, args);
      }
    }
  }
  once(eventName, listener) {
    const that = this;
    this.on(eventName, function oneTimeListener(...args) {
      that.removeListener(eventName, oneTimeListener);
      listener.apply(that, args);
    });
  }
};

// ../../node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewInstanceEvents/useTreeViewInstanceEvents.js
var isSyntheticEvent = (event) => {
  return event.isPropagationStopped !== void 0;
};
var useTreeViewInstanceEvents = () => {
  const [eventManager] = React4.useState(() => new EventManager());
  const publishEvent = React4.useCallback((...args) => {
    const [name, params, event = {}] = args;
    event.defaultMuiPrevented = false;
    if (isSyntheticEvent(event) && event.isPropagationStopped()) {
      return;
    }
    eventManager.emit(name, params, event);
  }, [eventManager]);
  const subscribeEvent = React4.useCallback((event, handler) => {
    eventManager.on(event, handler);
    return () => {
      eventManager.removeListener(event, handler);
    };
  }, [eventManager]);
  return {
    instance: {
      $$publishEvent: publishEvent,
      $$subscribeEvent: subscribeEvent
    }
  };
};
useTreeViewInstanceEvents.params = {};

// ../../node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewOptionalPlugins/useTreeViewOptionalPlugins.js
var useTreeViewOptionalPlugins = ({
  plugins
}) => {
  const pluginSet = new Set(plugins);
  const getAvailablePlugins = () => pluginSet;
  return {
    instance: {
      getAvailablePlugins
    }
  };
};
useTreeViewOptionalPlugins.params = {};

// ../../node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewId/useTreeViewId.js
var React5 = __toESM(require_react(), 1);

// ../../node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewId/useTreeViewId.selectors.js
var idSelectors = {
  /**
   * Get the id attribute of the tree view.
   * @param {TreeViewState<[UseTreeViewIdSignature]>} state The state of the tree view.
   * @returns {string} The id attribute of the tree view.
   */
  treeId: createSelector2((state) => state.id.treeId)
};

// ../../node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewId/useTreeViewId.utils.js
var globalTreeViewDefaultId = 0;
var createTreeViewDefaultId = () => {
  globalTreeViewDefaultId += 1;
  return `mui-tree-view-${globalTreeViewDefaultId}`;
};
var generateTreeItemIdAttribute = ({
  id,
  treeId = "",
  itemId
}) => {
  if (id != null) {
    return id;
  }
  return `${treeId}-${itemId}`;
};

// ../../node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewId/useTreeViewId.js
var useTreeViewId = ({
  params,
  store
}) => {
  React5.useEffect(() => {
    const prevIdState = store.state.id;
    if (params.id === prevIdState.providedTreeId && prevIdState.treeId !== void 0) {
      return;
    }
    store.set("id", _extends({}, prevIdState, {
      treeId: params.id ?? createTreeViewDefaultId()
    }));
  }, [store, params.id]);
  const treeId = useStore(store, idSelectors.treeId);
  return {
    getRootProps: () => ({
      id: treeId
    })
  };
};
useTreeViewId.params = {
  id: true
};
useTreeViewId.getInitialState = ({
  id
}) => ({
  id: {
    treeId: void 0,
    providedTreeId: id
  }
});

// ../../node_modules/@mui/x-tree-view/esm/internals/corePlugins/corePlugins.js
var TREE_VIEW_CORE_PLUGINS = [useTreeViewInstanceEvents, useTreeViewOptionalPlugins, useTreeViewId];

// ../../node_modules/@mui/x-tree-view/esm/internals/useTreeView/useExtractPluginParamsFromProps.js
var React6 = __toESM(require_react(), 1);
var _excluded = ["apiRef"];
var useExtractPluginParamsFromProps = (_ref) => {
  let {
    props: {
      apiRef
    },
    plugins
  } = _ref, props = _objectWithoutPropertiesLoose(_ref.props, _excluded);
  const paramsLookup = React6.useMemo(() => {
    const tempParamsLookup = {};
    plugins.forEach((plugin) => {
      Object.assign(tempParamsLookup, plugin.params);
    });
    return tempParamsLookup;
  }, [plugins]);
  const {
    forwardedProps,
    pluginParams
  } = React6.useMemo(() => {
    const tempPluginParams = {};
    const tempForwardedProps = {};
    Object.keys(props).forEach((propName) => {
      const prop = props[propName];
      if (paramsLookup[propName]) {
        tempPluginParams[propName] = prop;
      } else {
        tempForwardedProps[propName] = prop;
      }
    });
    const pluginParamsWithDefaults = plugins.reduce((acc, plugin) => {
      if (plugin.applyDefaultValuesToParams) {
        return plugin.applyDefaultValuesToParams({
          params: acc
        });
      }
      return acc;
    }, tempPluginParams);
    return {
      forwardedProps: tempForwardedProps,
      pluginParams: pluginParamsWithDefaults
    };
  }, [plugins, props, paramsLookup]);
  return {
    forwardedProps,
    pluginParams,
    apiRef
  };
};

// ../../node_modules/@mui/x-tree-view/esm/internals/useTreeView/useTreeViewBuildContext.js
var React7 = __toESM(require_react(), 1);
var useTreeViewBuildContext = (parameters) => {
  const {
    plugins,
    instance,
    publicAPI,
    store,
    rootRef
  } = parameters;
  const runItemPlugins = React7.useCallback((itemPluginProps) => {
    let finalRootRef = null;
    let finalContentRef = null;
    const pluginPropEnhancers = [];
    const pluginPropEnhancersNames = {};
    plugins.forEach((plugin) => {
      if (!plugin.itemPlugin) {
        return;
      }
      const itemPluginResponse = plugin.itemPlugin({
        props: itemPluginProps,
        rootRef: finalRootRef,
        contentRef: finalContentRef
      });
      if (itemPluginResponse?.rootRef) {
        finalRootRef = itemPluginResponse.rootRef;
      }
      if (itemPluginResponse?.contentRef) {
        finalContentRef = itemPluginResponse.contentRef;
      }
      if (itemPluginResponse?.propsEnhancers) {
        pluginPropEnhancers.push(itemPluginResponse.propsEnhancers);
        Object.keys(itemPluginResponse.propsEnhancers).forEach((propsEnhancerName) => {
          pluginPropEnhancersNames[propsEnhancerName] = true;
        });
      }
    });
    const resolvePropsEnhancer = (currentSlotName) => (currentSlotParams) => {
      const enhancedProps = {};
      pluginPropEnhancers.forEach((propsEnhancersForCurrentPlugin) => {
        const propsEnhancerForCurrentPluginAndSlot = propsEnhancersForCurrentPlugin[currentSlotName];
        if (propsEnhancerForCurrentPluginAndSlot != null) {
          Object.assign(enhancedProps, propsEnhancerForCurrentPluginAndSlot(currentSlotParams));
        }
      });
      return enhancedProps;
    };
    const propsEnhancers = Object.fromEntries(Object.keys(pluginPropEnhancersNames).map((propEnhancerName) => [propEnhancerName, resolvePropsEnhancer(propEnhancerName)]));
    return {
      contentRef: finalContentRef,
      rootRef: finalRootRef,
      propsEnhancers
    };
  }, [plugins]);
  const wrapItem = React7.useCallback(({
    itemId,
    children,
    idAttribute
  }) => {
    let finalChildren = children;
    for (let i = plugins.length - 1; i >= 0; i -= 1) {
      const plugin = plugins[i];
      if (plugin.wrapItem) {
        finalChildren = plugin.wrapItem({
          instance,
          itemId,
          children: finalChildren,
          idAttribute
        });
      }
    }
    return finalChildren;
  }, [plugins, instance]);
  const wrapRoot = React7.useCallback(({
    children
  }) => {
    let finalChildren = children;
    for (let i = plugins.length - 1; i >= 0; i -= 1) {
      const plugin = plugins[i];
      if (plugin.wrapRoot) {
        finalChildren = plugin.wrapRoot({
          children: finalChildren
        });
      }
    }
    return finalChildren;
  }, [plugins]);
  return React7.useMemo(() => ({
    runItemPlugins,
    wrapItem,
    wrapRoot,
    instance,
    publicAPI,
    store,
    rootRef
  }), [runItemPlugins, wrapItem, wrapRoot, instance, publicAPI, store, rootRef]);
};

// ../../node_modules/@mui/x-tree-view/esm/internals/useTreeView/useTreeView.js
function initializeInputApiRef(inputApiRef) {
  if (inputApiRef.current == null) {
    inputApiRef.current = {};
  }
  return inputApiRef;
}
function useTreeViewApiInitialization(inputApiRef) {
  const fallbackPublicApiRef = React8.useRef({});
  if (inputApiRef) {
    return initializeInputApiRef(inputApiRef);
  }
  return fallbackPublicApiRef;
}
var useTreeView = ({
  plugins: inPlugins,
  rootRef,
  props
}) => {
  const plugins = React8.useMemo(() => [...TREE_VIEW_CORE_PLUGINS, ...inPlugins], [inPlugins]);
  const {
    pluginParams,
    forwardedProps,
    apiRef
  } = useExtractPluginParamsFromProps({
    plugins,
    props
  });
  const instance = useRefWithInit(() => ({})).current;
  const publicAPI = useTreeViewApiInitialization(apiRef);
  const innerRootRef = React8.useRef(null);
  const handleRootRef = useMergedRefs(innerRootRef, rootRef);
  const store = useRefWithInit(() => {
    const initialState = {};
    for (const plugin of plugins) {
      if (plugin.getInitialState) {
        Object.assign(initialState, plugin.getInitialState(pluginParams));
      }
    }
    return new Store(initialState);
  }).current;
  const contextValue = useTreeViewBuildContext({
    plugins,
    instance,
    publicAPI: publicAPI.current,
    store,
    rootRef: innerRootRef
  });
  const rootPropsGetters = [];
  const runPlugin = (plugin) => {
    const pluginResponse = plugin({
      instance,
      params: pluginParams,
      rootRef: innerRootRef,
      plugins,
      store
    });
    if (pluginResponse.getRootProps) {
      rootPropsGetters.push(pluginResponse.getRootProps);
    }
    if (pluginResponse.publicAPI) {
      Object.assign(publicAPI.current, pluginResponse.publicAPI);
    }
    if (pluginResponse.instance) {
      Object.assign(instance, pluginResponse.instance);
    }
  };
  plugins.forEach(runPlugin);
  const getRootProps = (otherHandlers = {}) => {
    const rootProps = _extends({
      role: "tree"
    }, forwardedProps, otherHandlers, {
      ref: handleRootRef
    });
    rootPropsGetters.forEach((rootPropsGetter) => {
      Object.assign(rootProps, rootPropsGetter(otherHandlers));
    });
    return rootProps;
  };
  return {
    getRootProps,
    rootRef: handleRootRef,
    contextValue
  };
};

// ../../node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewProvider.js
var React11 = __toESM(require_react(), 1);

// ../../node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewContext.js
var React9 = __toESM(require_react(), 1);
var TreeViewContext = React9.createContext(null);
if (true) TreeViewContext.displayName = "TreeViewContext";
var useTreeViewContext = () => {
  const context = React9.useContext(TreeViewContext);
  if (context == null) {
    throw new Error(["MUI X: Could not find the Tree View context.", "It looks like you rendered your component outside of a SimpleTreeView or RichTreeView parent component.", "This can also happen if you are bundling multiple versions of the Tree View."].join("\n"));
  }
  return context;
};

// ../../node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewStyleContext.js
var React10 = __toESM(require_react(), 1);
var TreeViewStyleContext = React10.createContext({
  classes: {},
  slots: {},
  slotProps: {}
});
if (true) TreeViewStyleContext.displayName = "TreeViewStyleContext";
var useTreeViewStyleContext = () => {
  return React10.useContext(TreeViewStyleContext);
};

// ../../node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var EMPTY_OBJECT = {};
function TreeViewProvider(props) {
  const {
    contextValue,
    classes = EMPTY_OBJECT,
    slots = EMPTY_OBJECT,
    slotProps = EMPTY_OBJECT,
    children
  } = props;
  const styleContextValue = React11.useMemo(() => ({
    classes,
    slots: {
      collapseIcon: slots.collapseIcon,
      expandIcon: slots.expandIcon,
      endIcon: slots.endIcon
    },
    slotProps: {
      collapseIcon: slotProps.collapseIcon,
      expandIcon: slotProps.expandIcon,
      endIcon: slotProps.endIcon
    }
  }), [classes, slots.collapseIcon, slots.expandIcon, slots.endIcon, slotProps.collapseIcon, slotProps.expandIcon, slotProps.endIcon]);
  return (0, import_jsx_runtime.jsx)(TreeViewContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime.jsx)(TreeViewStyleContext.Provider, {
      value: styleContextValue,
      children: contextValue.wrapRoot({
        children
      })
    })
  });
}

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.js
var React14 = __toESM(require_react(), 1);

// ../../node_modules/@base-ui/utils/esm/useStableCallback.js
var React12 = __toESM(require_react());
var useInsertionEffect = React12[`useInsertionEffect${Math.random().toFixed(1)}`.slice(0, -3)];
var useSafeInsertionEffect = (
  // React 17 doesn't have useInsertionEffect.
  useInsertionEffect && // Preact replaces useInsertionEffect with useLayoutEffect and fires too late.
  useInsertionEffect !== React12.useLayoutEffect ? useInsertionEffect : (fn) => fn()
);
function useStableCallback(callback) {
  const stable = useRefWithInit(createStableCallback).current;
  stable.next = callback;
  useSafeInsertionEffect(stable.effect);
  return stable.trampoline;
}
function createStableCallback() {
  const stable = {
    next: void 0,
    callback: assertNotCalled,
    trampoline: (...args) => stable.callback?.(...args),
    effect: () => {
      stable.callback = stable.next;
    }
  };
  return stable;
}
function assertNotCalled() {
  if (true) {
    throw new Error("Base UI: Cannot call an event handler while rendering.");
  }
}

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.utils.js
var TREE_VIEW_ROOT_PARENT_ID = "__TREE_VIEW_ROOT_PARENT_ID__";
var buildSiblingIndexes = (siblings) => {
  const siblingsIndexLookup = {};
  siblings.forEach((childId, index) => {
    siblingsIndexLookup[childId] = index;
  });
  return siblingsIndexLookup;
};
var isItemDisabled = (itemMetaLookup, itemId) => {
  if (itemId == null) {
    return false;
  }
  let itemMeta = itemMetaLookup[itemId];
  if (!itemMeta) {
    return false;
  }
  if (itemMeta.disabled) {
    return true;
  }
  while (itemMeta.parentId != null) {
    itemMeta = itemMetaLookup[itemMeta.parentId];
    if (!itemMeta) {
      return false;
    }
    if (itemMeta.disabled) {
      return true;
    }
  }
  return false;
};
function buildItemsState(parameters) {
  const {
    config,
    items: itemsParam,
    disabledItemsFocusable
  } = parameters;
  const itemMetaLookup = {};
  const itemModelLookup = {};
  const itemOrderedChildrenIdsLookup = {};
  const itemChildrenIndexesLookup = {};
  function processSiblings(items, parentId, depth) {
    const parentIdWithDefault = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    const {
      metaLookup,
      modelLookup,
      orderedChildrenIds,
      childrenIndexes,
      itemsChildren
    } = buildItemsLookups({
      config,
      items,
      parentId,
      depth,
      isItemExpandable: (item, children) => !!children && children.length > 0,
      otherItemsMetaLookup: itemMetaLookup
    });
    Object.assign(itemMetaLookup, metaLookup);
    Object.assign(itemModelLookup, modelLookup);
    itemOrderedChildrenIdsLookup[parentIdWithDefault] = orderedChildrenIds;
    itemChildrenIndexesLookup[parentIdWithDefault] = childrenIndexes;
    for (const item of itemsChildren) {
      processSiblings(item.children || [], item.id, depth + 1);
    }
  }
  processSiblings(itemsParam, null, 0);
  return {
    disabledItemsFocusable,
    itemMetaLookup,
    itemModelLookup,
    itemOrderedChildrenIdsLookup,
    itemChildrenIndexesLookup,
    domStructure: "nested"
  };
}
function buildItemsLookups(parameters) {
  const {
    config,
    items,
    parentId,
    depth,
    isItemExpandable,
    otherItemsMetaLookup
  } = parameters;
  const metaLookup = {};
  const modelLookup = {};
  const orderedChildrenIds = [];
  const itemsChildren = [];
  const processItem = (item) => {
    const id = config.getItemId ? config.getItemId(item) : item.id;
    checkId({
      id,
      parentId,
      item,
      itemMetaLookup: otherItemsMetaLookup,
      siblingsMetaLookup: metaLookup
    });
    const label = config.getItemLabel ? config.getItemLabel(item) : item.label;
    if (label == null) {
      throw new Error(["MUI X: The Tree View component requires all items to have a `label` property.", "Alternatively, you can use the `getItemLabel` prop to specify a custom label for each item.", "An item was provided without label in the `items` prop:", JSON.stringify(item)].join("\n"));
    }
    const children = (config.getItemChildren ? config.getItemChildren(item) : item.children) || [];
    itemsChildren.push({
      id,
      children
    });
    modelLookup[id] = item;
    metaLookup[id] = {
      id,
      label,
      parentId,
      idAttribute: void 0,
      expandable: isItemExpandable(item, children),
      disabled: config.isItemDisabled ? config.isItemDisabled(item) : false,
      selectable: config.isItemSelectionDisabled ? !config.isItemSelectionDisabled(item) : true,
      depth
    };
    orderedChildrenIds.push(id);
  };
  for (const item of items) {
    processItem(item);
  }
  return {
    metaLookup,
    modelLookup,
    orderedChildrenIds,
    childrenIndexes: buildSiblingIndexes(orderedChildrenIds),
    itemsChildren
  };
}
function checkId({
  id,
  parentId,
  item,
  itemMetaLookup,
  siblingsMetaLookup
}) {
  if (id == null) {
    throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", "An item was provided without id in the `items` prop:", JSON.stringify(item)].join("\n"));
  }
  if (siblingsMetaLookup[id] != null || // Ignore items with the same parent id, because it's the same item from the previous generation.
  itemMetaLookup[id] != null && itemMetaLookup[id].parentId !== parentId) {
    throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", `Two items were provided with the same id in the \`items\` prop: "${id}"`].join("\n"));
  }
}

// ../../node_modules/@mui/x-tree-view/esm/internals/TreeViewItemDepthContext/TreeViewItemDepthContext.js
var React13 = __toESM(require_react(), 1);
var TreeViewItemDepthContext = React13.createContext(() => -1);
if (true) TreeViewItemDepthContext.displayName = "TreeViewItemDepthContext";

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.selectors.js
var EMPTY_CHILDREN = [];
var itemsSelectors = {
  /**
   * Gets the DOM structure of the Tree View.
   */
  domStructure: createSelector2((state) => state.items.domStructure),
  /**
   * Checks whether the disabled items are focusable.
   */
  disabledItemFocusable: createSelector2((state) => state.items.disabledItemsFocusable),
  /**
   * Gets the meta-information of all items.
   */
  itemMetaLookup: createSelector2((state) => state.items.itemMetaLookup),
  /**
   * Gets the ordered children ids of all items.
   */
  itemOrderedChildrenIdsLookup: createSelector2((state) => state.items.itemOrderedChildrenIdsLookup),
  /**
   * Gets the meta-information of an item.
   */
  itemMeta: createSelector2((state, itemId) => state.items.itemMetaLookup[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? null),
  /**
   * Gets the ordered children ids of an item.
   */
  itemOrderedChildrenIds: createSelector2((state, itemId) => state.items.itemOrderedChildrenIdsLookup[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? EMPTY_CHILDREN),
  /**
   * Gets the model of an item.
   */
  itemModel: createSelector2((state, itemId) => state.items.itemModelLookup[itemId]),
  /**
   * Checks whether an item is disabled.
   */
  isItemDisabled: createSelector2((state, itemId) => isItemDisabled(state.items.itemMetaLookup, itemId)),
  /**
   * Gets the index of an item in its parent's children.
   */
  itemIndex: createSelector2((state, itemId) => {
    const itemMeta = state.items.itemMetaLookup[itemId];
    if (itemMeta == null) {
      return -1;
    }
    const parentIndexes = state.items.itemChildrenIndexesLookup[itemMeta.parentId ?? TREE_VIEW_ROOT_PARENT_ID];
    return parentIndexes[itemMeta.id];
  }),
  /**
   * Gets the id of an item's parent.
   */
  itemParentId: createSelector2((state, itemId) => state.items.itemMetaLookup[itemId]?.parentId ?? null),
  /**
   * Gets the depth of an item (items at the root level have a depth of 0).
   */
  itemDepth: createSelector2((state, itemId) => state.items.itemMetaLookup[itemId]?.depth ?? 0),
  /**
   * Checks whether an item can be focused.
   */
  canItemBeFocused: createSelector2((state, itemId) => state.items.disabledItemsFocusable || !isItemDisabled(state.items.itemMetaLookup, itemId)),
  /**
   * Checks whether an item is selectable based on the `isItemSelectionDisabled` prop.
   */
  isItemSelectable: createSelector2((state, itemId) => state.items.itemMetaLookup[itemId]?.selectable ?? true)
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var defaultIsItemSelectionDisabled = (item) => item.disableSelection === true;
var useTreeViewItems = ({
  instance,
  params,
  store
}) => {
  const itemsConfig = React14.useMemo(() => ({
    isItemDisabled: params.isItemDisabled,
    isItemSelectionDisabled: params.isItemSelectionDisabled,
    getItemLabel: params.getItemLabel,
    getItemChildren: params.getItemChildren,
    getItemId: params.getItemId
  }), [params.isItemDisabled, params.isItemSelectionDisabled, params.getItemLabel, params.getItemChildren, params.getItemId]);
  const getItem = React14.useCallback((itemId) => itemsSelectors.itemModel(store.state, itemId), [store]);
  const getParentId = React14.useCallback((itemId) => {
    const itemMeta = itemsSelectors.itemMeta(store.state, itemId);
    return itemMeta?.parentId || null;
  }, [store]);
  const setIsItemDisabled = useStableCallback(({
    itemId,
    shouldBeDisabled
  }) => {
    if (!store.state.items.itemMetaLookup[itemId]) {
      return;
    }
    const itemMetaLookup = _extends({}, store.state.items.itemMetaLookup);
    itemMetaLookup[itemId] = _extends({}, itemMetaLookup[itemId], {
      disabled: shouldBeDisabled ?? !itemMetaLookup[itemId].disabled
    });
    store.set("items", _extends({}, store.state.items, {
      itemMetaLookup
    }));
  });
  const getItemTree = React14.useCallback(() => {
    const getItemFromItemId = (itemId) => {
      const item = itemsSelectors.itemModel(store.state, itemId);
      const itemToMutate = _extends({}, item);
      const newChildren = itemsSelectors.itemOrderedChildrenIds(store.state, itemId);
      if (newChildren.length > 0) {
        itemToMutate.children = newChildren.map(getItemFromItemId);
      } else {
        delete itemToMutate.children;
      }
      return itemToMutate;
    };
    return itemsSelectors.itemOrderedChildrenIds(store.state, null).map(getItemFromItemId);
  }, [store]);
  const getItemOrderedChildrenIds = React14.useCallback((itemId) => itemsSelectors.itemOrderedChildrenIds(store.state, itemId), [store]);
  const getItemDOMElement = (itemId) => {
    const itemMeta = itemsSelectors.itemMeta(store.state, itemId);
    if (itemMeta == null) {
      return null;
    }
    const idAttribute = generateTreeItemIdAttribute({
      treeId: idSelectors.treeId(store.state),
      itemId,
      id: itemMeta.idAttribute
    });
    return document.getElementById(idAttribute);
  };
  const areItemUpdatesPreventedRef = React14.useRef(false);
  const preventItemUpdates = React14.useCallback(() => {
    areItemUpdatesPreventedRef.current = true;
  }, []);
  const areItemUpdatesPrevented = React14.useCallback(() => areItemUpdatesPreventedRef.current, []);
  const setItemChildren = ({
    items,
    parentId,
    getChildrenCount
  }) => {
    const parentIdWithDefault = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    const parentDepth = parentId == null ? -1 : itemsSelectors.itemDepth(store.state, parentId);
    const {
      metaLookup,
      modelLookup,
      orderedChildrenIds,
      childrenIndexes
    } = buildItemsLookups({
      config: itemsConfig,
      items,
      parentId,
      depth: parentDepth + 1,
      isItemExpandable: getChildrenCount ? (item) => getChildrenCount(item) > 0 : () => false,
      otherItemsMetaLookup: itemsSelectors.itemMetaLookup(store.state)
    });
    const lookups = {
      itemModelLookup: _extends({}, store.state.items.itemModelLookup, modelLookup),
      itemMetaLookup: _extends({}, store.state.items.itemMetaLookup, metaLookup),
      itemOrderedChildrenIdsLookup: _extends({}, store.state.items.itemOrderedChildrenIdsLookup, {
        [parentIdWithDefault]: orderedChildrenIds
      }),
      itemChildrenIndexesLookup: _extends({}, store.state.items.itemChildrenIndexesLookup, {
        [parentIdWithDefault]: childrenIndexes
      })
    };
    store.set("items", _extends({}, store.state.items, lookups));
  };
  const removeChildren = useStableCallback((parentId) => {
    const newMetaMap = Object.keys(store.state.items.itemMetaLookup).reduce((acc, key) => {
      const item = store.state.items.itemMetaLookup[key];
      if (item.parentId === parentId) {
        return acc;
      }
      return _extends({}, acc, {
        [item.id]: item
      });
    }, {});
    const newItemOrderedChildrenIdsLookup = _extends({}, store.state.items.itemOrderedChildrenIdsLookup);
    const newItemChildrenIndexesLookup = _extends({}, store.state.items.itemChildrenIndexesLookup);
    const cleanId = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    delete newItemChildrenIndexesLookup[cleanId];
    delete newItemOrderedChildrenIdsLookup[cleanId];
    store.set("items", _extends({}, store.state.items, {
      itemMetaLookup: newMetaMap,
      itemOrderedChildrenIdsLookup: newItemOrderedChildrenIdsLookup,
      itemChildrenIndexesLookup: newItemChildrenIndexesLookup
    }));
  });
  const addExpandableItems = useStableCallback((items) => {
    const newItemMetaLookup = _extends({}, store.state.items.itemMetaLookup);
    for (const itemId of items) {
      newItemMetaLookup[itemId] = _extends({}, newItemMetaLookup[itemId], {
        expandable: true
      });
    }
    store.set("items", _extends({}, store.state.items, {
      itemMetaLookup: newItemMetaLookup
    }));
  });
  React14.useEffect(() => {
    if (instance.areItemUpdatesPrevented()) {
      return;
    }
    const newState = buildItemsState({
      disabledItemsFocusable: params.disabledItemsFocusable,
      items: params.items,
      config: itemsConfig
    });
    store.set("items", _extends({}, store.state.items, newState));
  }, [instance, store, params.items, params.disabledItemsFocusable, itemsConfig]);
  const handleItemClick = useStableCallback((event, itemId) => {
    if (params.onItemClick) {
      params.onItemClick(event, itemId);
    }
  });
  return {
    getRootProps: () => ({
      style: {
        "--TreeView-itemChildrenIndentation": typeof params.itemChildrenIndentation === "number" ? `${params.itemChildrenIndentation}px` : params.itemChildrenIndentation
      }
    }),
    publicAPI: {
      getItem,
      getItemDOMElement,
      getItemTree,
      getItemOrderedChildrenIds,
      setIsItemDisabled,
      getParentId
    },
    instance: {
      getItemDOMElement,
      preventItemUpdates,
      areItemUpdatesPrevented,
      setItemChildren,
      removeChildren,
      addExpandableItems,
      handleItemClick
    }
  };
};
useTreeViewItems.getInitialState = (params) => ({
  items: buildItemsState({
    items: params.items,
    disabledItemsFocusable: params.disabledItemsFocusable,
    config: {
      isItemDisabled: params.isItemDisabled,
      isItemSelectionDisabled: params.isItemSelectionDisabled,
      getItemId: params.getItemId,
      getItemLabel: params.getItemLabel,
      getItemChildren: params.getItemChildren
    }
  })
});
useTreeViewItems.applyDefaultValuesToParams = ({
  params
}) => _extends({}, params, {
  disabledItemsFocusable: params.disabledItemsFocusable ?? false,
  itemChildrenIndentation: params.itemChildrenIndentation ?? "12px",
  isItemSelectionDisabled: params.isItemSelectionDisabled ?? defaultIsItemSelectionDisabled
});
useTreeViewItems.wrapRoot = ({
  children
}) => {
  return (0, import_jsx_runtime2.jsx)(TreeViewItemDepthContext.Provider, {
    value: itemsSelectors.itemDepth,
    children
  });
};
if (true) useTreeViewItems.wrapRoot.displayName = "useTreeViewItems.wrapRoot";
useTreeViewItems.params = {
  disabledItemsFocusable: true,
  items: true,
  isItemDisabled: true,
  isItemSelectionDisabled: true,
  getItemLabel: true,
  getItemChildren: true,
  getItemId: true,
  onItemClick: true,
  itemChildrenIndentation: true
};

// ../../node_modules/@mui/x-internals/esm/useAssertModelConsistency/useAssertModelConsistency.js
var React15 = __toESM(require_react(), 1);
function useAssertModelConsistencyOutsideOfProduction(parameters) {
  const {
    componentName,
    propName,
    controlled,
    defaultValue,
    warningPrefix = "MUI X"
  } = parameters;
  const [{
    initialDefaultValue,
    isControlled
  }] = React15.useState({
    initialDefaultValue: defaultValue,
    isControlled: controlled !== void 0
  });
  if (isControlled !== (controlled !== void 0)) {
    warnOnce([`${warningPrefix}: A component is changing the ${isControlled ? "" : "un"}controlled ${propName} state of ${componentName} to be ${isControlled ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${propName} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"], "error");
  }
  if (JSON.stringify(initialDefaultValue) !== JSON.stringify(defaultValue)) {
    warnOnce([`${warningPrefix}: A component is changing the default ${propName} state of an uncontrolled ${componentName} after being initialized. To suppress this warning opt to use a controlled ${componentName}.`], "error");
  }
}
var useAssertModelConsistency = false ? () => {
} : useAssertModelConsistencyOutsideOfProduction;

// ../../node_modules/@base-ui/utils/esm/useIsoLayoutEffect.js
var React16 = __toESM(require_react());
var noop2 = () => {
};
var useIsoLayoutEffect = typeof document !== "undefined" ? React16.useLayoutEffect : noop2;

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewExpansion/useTreeViewExpansion.selectors.js
var expandedItemMapSelector = createSelectorMemoized((state) => state.expansion.expandedItems, (expandedItems) => {
  const expandedItemsMap = /* @__PURE__ */ new Map();
  expandedItems.forEach((id) => {
    expandedItemsMap.set(id, true);
  });
  return expandedItemsMap;
});
var expansionSelectors = {
  /**
   * Gets the expanded items as provided to the component.
   */
  expandedItemsRaw: createSelector2((state) => state.expansion.expandedItems),
  /**
   * Gets the expanded items as a Map.
   */
  expandedItemsMap: expandedItemMapSelector,
  /**
   * Gets the items to render as a flat list (the descendants of an expanded item are listed as siblings of the item).
   */
  flatList: createSelectorMemoized(itemsSelectors.itemOrderedChildrenIdsLookup, expandedItemMapSelector, (itemOrderedChildrenIds, expandedItemsMap) => {
    function appendChildren(itemId) {
      if (!expandedItemsMap.has(itemId)) {
        return [itemId];
      }
      const itemsWithDescendants = [itemId];
      const children = itemOrderedChildrenIds[itemId] || [];
      for (const childId of children) {
        itemsWithDescendants.push(...appendChildren(childId));
      }
      return itemsWithDescendants;
    }
    return (itemOrderedChildrenIds[TREE_VIEW_ROOT_PARENT_ID] ?? []).flatMap(appendChildren);
  }),
  /**
   * Gets the slot that triggers the item's expansion when clicked.
   */
  triggerSlot: createSelector2((state) => state.expansion.expansionTrigger),
  /**
   * Checks whether an item is expanded.
   */
  isItemExpanded: createSelector2(expandedItemMapSelector, (expandedItemsMap, itemId) => expandedItemsMap.has(itemId)),
  /**
   * Checks whether an item is expandable.
   */
  isItemExpandable: createSelector2(itemsSelectors.itemMeta, (itemMeta, _itemId) => itemMeta?.expandable ?? false)
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewExpansion/useTreeViewExpansion.utils.js
var getExpansionTrigger = ({
  isItemEditable,
  expansionTrigger
}) => {
  if (expansionTrigger) {
    return expansionTrigger;
  }
  if (isItemEditable) {
    return "iconContainer";
  }
  return "content";
};

// ../../node_modules/@mui/x-tree-view/esm/internals/utils/publishTreeViewEvent.js
var publishTreeViewEvent = (instance, eventName, params) => {
  instance.$$publishEvent(eventName, params);
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewExpansion/useTreeViewExpansion.js
var useTreeViewExpansion = ({
  instance,
  store,
  params
}) => {
  useAssertModelConsistency({
    componentName: "Tree View",
    propName: "expandedItems",
    controlled: params.expandedItems,
    defaultValue: params.defaultExpandedItems
  });
  useIsoLayoutEffect(() => {
    const newExpansionTrigger = getExpansionTrigger({
      isItemEditable: params.isItemEditable,
      expansionTrigger: params.expansionTrigger
    });
    if (store.state.expansion.expansionTrigger === newExpansionTrigger) {
      return;
    }
    store.set("expansion", _extends({}, store.state.expansion, {
      expansionTrigger: newExpansionTrigger
    }));
  }, [store, params.isItemEditable, params.expansionTrigger]);
  const setExpandedItems = (event, value) => {
    if (params.expandedItems === void 0) {
      store.set("expansion", _extends({}, store.state.expansion, {
        expandedItems: value
      }));
    }
    params.onExpandedItemsChange?.(event, value);
  };
  const resetItemExpansion = useStableCallback(() => {
    setExpandedItems(null, []);
  });
  const applyItemExpansion = useStableCallback(({
    itemId,
    event,
    shouldBeExpanded
  }) => {
    const oldExpanded = expansionSelectors.expandedItemsRaw(store.state);
    let newExpanded;
    if (shouldBeExpanded) {
      newExpanded = [itemId].concat(oldExpanded);
    } else {
      newExpanded = oldExpanded.filter((id) => id !== itemId);
    }
    if (params.onItemExpansionToggle) {
      params.onItemExpansionToggle(event, itemId, shouldBeExpanded);
    }
    setExpandedItems(event, newExpanded);
  });
  const setItemExpansion = useStableCallback(({
    itemId,
    event = null,
    shouldBeExpanded
  }) => {
    const isExpandedBefore = expansionSelectors.isItemExpanded(store.state, itemId);
    const cleanShouldBeExpanded = shouldBeExpanded ?? !isExpandedBefore;
    if (isExpandedBefore === cleanShouldBeExpanded) {
      return;
    }
    const eventParameters = {
      isExpansionPrevented: false,
      shouldBeExpanded: cleanShouldBeExpanded,
      event,
      itemId
    };
    publishTreeViewEvent(instance, "beforeItemToggleExpansion", eventParameters);
    if (eventParameters.isExpansionPrevented) {
      return;
    }
    instance.applyItemExpansion({
      itemId,
      event,
      shouldBeExpanded: cleanShouldBeExpanded
    });
  });
  const isItemExpanded = useStableCallback((itemId) => {
    return expansionSelectors.isItemExpanded(store.state, itemId);
  });
  const expandAllSiblings = (event, itemId) => {
    const itemMeta = itemsSelectors.itemMeta(store.state, itemId);
    if (itemMeta == null) {
      return;
    }
    const siblings = itemsSelectors.itemOrderedChildrenIds(store.state, itemMeta.parentId);
    const diff = siblings.filter((child) => expansionSelectors.isItemExpandable(store.state, child) && !expansionSelectors.isItemExpanded(store.state, child));
    const newExpanded = expansionSelectors.expandedItemsRaw(store.state).concat(diff);
    if (diff.length > 0) {
      if (params.onItemExpansionToggle) {
        diff.forEach((newlyExpandedItemId) => {
          params.onItemExpansionToggle(event, newlyExpandedItemId, true);
        });
      }
      setExpandedItems(event, newExpanded);
    }
  };
  useIsoLayoutEffect(() => {
    const expandedItems = params.expandedItems;
    if (expandedItems !== void 0) {
      store.set("expansion", _extends({}, store.state.expansion, {
        expandedItems
      }));
    }
  }, [store, params.expandedItems]);
  return {
    publicAPI: {
      setItemExpansion,
      isItemExpanded
    },
    instance: {
      setItemExpansion,
      applyItemExpansion,
      expandAllSiblings,
      resetItemExpansion
    }
  };
};
var DEFAULT_EXPANDED_ITEMS = [];
useTreeViewExpansion.applyDefaultValuesToParams = ({
  params
}) => _extends({}, params, {
  defaultExpandedItems: params.defaultExpandedItems ?? DEFAULT_EXPANDED_ITEMS
});
useTreeViewExpansion.getInitialState = (params) => ({
  expansion: {
    expandedItems: params.expandedItems === void 0 ? params.defaultExpandedItems : params.expandedItems,
    expansionTrigger: getExpansionTrigger(params)
  }
});
useTreeViewExpansion.params = {
  expandedItems: true,
  defaultExpandedItems: true,
  onExpandedItemsChange: true,
  onItemExpansionToggle: true,
  expansionTrigger: true
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/useTreeViewSelection.js
var React17 = __toESM(require_react(), 1);

// ../../node_modules/@mui/x-tree-view/esm/internals/utils/tree.js
var getLastNavigableItemInArray = (state, items) => {
  let itemIndex = items.length - 1;
  while (itemIndex >= 0 && !itemsSelectors.canItemBeFocused(state, items[itemIndex])) {
    itemIndex -= 1;
  }
  if (itemIndex === -1) {
    return void 0;
  }
  return items[itemIndex];
};
var getPreviousNavigableItem = (state, itemId) => {
  const itemMeta = itemsSelectors.itemMeta(state, itemId);
  if (!itemMeta) {
    return null;
  }
  const siblings = itemsSelectors.itemOrderedChildrenIds(state, itemMeta.parentId);
  const itemIndex = itemsSelectors.itemIndex(state, itemId);
  if (itemIndex === 0) {
    return itemMeta.parentId;
  }
  let previousNavigableSiblingIndex = itemIndex - 1;
  while (!itemsSelectors.canItemBeFocused(state, siblings[previousNavigableSiblingIndex]) && previousNavigableSiblingIndex >= 0) {
    previousNavigableSiblingIndex -= 1;
  }
  if (previousNavigableSiblingIndex === -1) {
    if (itemMeta.parentId == null) {
      return null;
    }
    return getPreviousNavigableItem(state, itemMeta.parentId);
  }
  let currentItemId = siblings[previousNavigableSiblingIndex];
  let lastNavigableChild = getLastNavigableItemInArray(state, itemsSelectors.itemOrderedChildrenIds(state, currentItemId));
  while (expansionSelectors.isItemExpanded(state, currentItemId) && lastNavigableChild != null) {
    currentItemId = lastNavigableChild;
    lastNavigableChild = getLastNavigableItemInArray(state, itemsSelectors.itemOrderedChildrenIds(state, currentItemId));
  }
  return currentItemId;
};
var getNextNavigableItem = (state, itemId) => {
  if (expansionSelectors.isItemExpanded(state, itemId)) {
    const firstNavigableChild = itemsSelectors.itemOrderedChildrenIds(state, itemId).find((childId) => itemsSelectors.canItemBeFocused(state, childId));
    if (firstNavigableChild != null) {
      return firstNavigableChild;
    }
  }
  let itemMeta = itemsSelectors.itemMeta(state, itemId);
  while (itemMeta != null) {
    const siblings = itemsSelectors.itemOrderedChildrenIds(state, itemMeta.parentId);
    const currentItemIndex = itemsSelectors.itemIndex(state, itemMeta.id);
    if (currentItemIndex < siblings.length - 1) {
      let nextItemIndex = currentItemIndex + 1;
      while (!itemsSelectors.canItemBeFocused(state, siblings[nextItemIndex]) && nextItemIndex < siblings.length - 1) {
        nextItemIndex += 1;
      }
      if (itemsSelectors.canItemBeFocused(state, siblings[nextItemIndex])) {
        return siblings[nextItemIndex];
      }
    }
    itemMeta = itemsSelectors.itemMeta(state, itemMeta.parentId);
  }
  return null;
};
var getLastNavigableItem = (state) => {
  let itemId = null;
  while (itemId == null || expansionSelectors.isItemExpanded(state, itemId)) {
    const children = itemsSelectors.itemOrderedChildrenIds(state, itemId);
    const lastNavigableChild = getLastNavigableItemInArray(state, children);
    if (lastNavigableChild == null) {
      return itemId;
    }
    itemId = lastNavigableChild;
  }
  return itemId;
};
var getFirstNavigableItem = (state) => itemsSelectors.itemOrderedChildrenIds(state, null).find((itemId) => itemsSelectors.canItemBeFocused(state, itemId));
var findOrderInTremauxTree = (state, itemAId, itemBId) => {
  if (itemAId === itemBId) {
    return [itemAId, itemBId];
  }
  const itemMetaA = itemsSelectors.itemMeta(state, itemAId);
  const itemMetaB = itemsSelectors.itemMeta(state, itemBId);
  if (!itemMetaA || !itemMetaB) {
    return [itemAId, itemBId];
  }
  if (itemMetaA.parentId === itemMetaB.id || itemMetaB.parentId === itemMetaA.id) {
    return itemMetaB.parentId === itemMetaA.id ? [itemMetaA.id, itemMetaB.id] : [itemMetaB.id, itemMetaA.id];
  }
  const aFamily = [itemMetaA.id];
  const bFamily = [itemMetaB.id];
  let aAncestor = itemMetaA.parentId;
  let bAncestor = itemMetaB.parentId;
  let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
  let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
  let continueA = true;
  let continueB = true;
  while (!bAncestorIsCommon && !aAncestorIsCommon) {
    if (continueA) {
      aFamily.push(aAncestor);
      aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
      continueA = aAncestor !== null;
      if (!aAncestorIsCommon && continueA) {
        aAncestor = itemsSelectors.itemParentId(state, aAncestor);
      }
    }
    if (continueB && !aAncestorIsCommon) {
      bFamily.push(bAncestor);
      bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
      continueB = bAncestor !== null;
      if (!bAncestorIsCommon && continueB) {
        bAncestor = itemsSelectors.itemParentId(state, bAncestor);
      }
    }
  }
  const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;
  const ancestorFamily = itemsSelectors.itemOrderedChildrenIds(state, commonAncestor);
  const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];
  const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];
  return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [itemAId, itemBId] : [itemBId, itemAId];
};
var getNonDisabledItemsInRange = (state, itemAId, itemBId) => {
  const getNextItem = (itemId) => {
    if (expansionSelectors.isItemExpandable(state, itemId) && expansionSelectors.isItemExpanded(state, itemId)) {
      return itemsSelectors.itemOrderedChildrenIds(state, itemId)[0];
    }
    let itemMeta = itemsSelectors.itemMeta(state, itemId);
    while (itemMeta != null) {
      const siblings = itemsSelectors.itemOrderedChildrenIds(state, itemMeta.parentId);
      const currentItemIndex = itemsSelectors.itemIndex(state, itemMeta.id);
      if (currentItemIndex < siblings.length - 1) {
        return siblings[currentItemIndex + 1];
      }
      itemMeta = itemMeta.parentId ? itemsSelectors.itemMeta(state, itemMeta.parentId) : null;
    }
    throw new Error("Invalid range");
  };
  const [first, last] = findOrderInTremauxTree(state, itemAId, itemBId);
  const items = [first];
  let current = first;
  while (current !== last) {
    current = getNextItem(current);
    if (!itemsSelectors.isItemDisabled(state, current)) {
      items.push(current);
    }
  }
  return items;
};
var getAllNavigableItems = (state) => {
  let item = getFirstNavigableItem(state);
  const navigableItems = [];
  while (item != null) {
    navigableItems.push(item);
    item = getNextNavigableItem(state, item);
  }
  return navigableItems;
};
var isTargetInDescendants = (target, itemRoot) => {
  return itemRoot !== target.closest('*[role="treeitem"]');
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/useTreeViewSelection.selectors.js
var selectedItemsSelector = createSelectorMemoized((state) => state.selection.selectedItems, (selectedItemsRaw) => {
  if (Array.isArray(selectedItemsRaw)) {
    return selectedItemsRaw;
  }
  if (selectedItemsRaw != null) {
    return [selectedItemsRaw];
  }
  return [];
});
var selectedItemsMapSelector = createSelectorMemoized(selectedItemsSelector, (selectedItems) => {
  const selectedItemsMap = /* @__PURE__ */ new Map();
  selectedItems.forEach((id) => {
    selectedItemsMap.set(id, true);
  });
  return selectedItemsMap;
});
var selectionSelectors = {
  /**
   * Gets the selected items as provided to the component.
   */
  selectedItemsRaw: createSelector2((state) => state.selection.selectedItems),
  /**
   * Gets the selected items as an array.
   */
  selectedItems: selectedItemsSelector,
  /**
   * Gets the selected items as a Map.
   */
  selectedItemsMap: selectedItemsMapSelector,
  /**
   * Checks whether selection is enabled.
   */
  enabled: createSelector2((state) => state.selection.isEnabled),
  /**
   * Checks whether multi selection is enabled.
   */
  isMultiSelectEnabled: createSelector2((state) => state.selection.isMultiSelectEnabled),
  /**
   * Checks whether checkbox selection is enabled.
   */
  isCheckboxSelectionEnabled: createSelector2((state) => state.selection.isCheckboxSelectionEnabled),
  /**
   * Gets the selection propagation rules.
   */
  propagationRules: createSelector2((state) => state.selection.selectionPropagation),
  /**
   * Checks whether an item is selected.
   */
  isItemSelected: createSelector2(selectedItemsMapSelector, (selectedItemsMap, itemId) => selectedItemsMap.has(itemId)),
  /**
   * Checks whether the selection feature is enabled for an item.
   * Returns `true` when selection is enabled on the Tree View and the item is selectable (even if the item is disabled).
   */
  isFeatureEnabledForItem: createSelector2(itemsSelectors.isItemSelectable, (state) => state.selection.isEnabled, (isItemSelectable, isSelectionEnabled, _itemId) => isSelectionEnabled && isItemSelectable),
  /**
   * Checks whether an item can be selected (if selection is enabled, if the item is not disabled, and if the item is selectable).
   */
  canItemBeSelected: createSelector2(itemsSelectors.isItemDisabled, itemsSelectors.isItemSelectable, (state) => state.selection.isEnabled, (isItemDisabled2, isItemSelectable, isSelectionEnabled, _itemId) => isSelectionEnabled && !isItemDisabled2 && isItemSelectable)
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/useTreeViewSelection.utils.js
var getLookupFromArray = (array) => {
  const lookup = {};
  array.forEach((itemId) => {
    lookup[itemId] = true;
  });
  return lookup;
};
var getAddedAndRemovedItems = ({
  store,
  oldModel,
  newModel
}) => {
  const newModelMap = /* @__PURE__ */ new Map();
  newModel.forEach((id) => {
    newModelMap.set(id, true);
  });
  return {
    added: newModel.filter((itemId) => !selectionSelectors.isItemSelected(store.state, itemId)),
    removed: oldModel.filter((itemId) => !newModelMap.has(itemId))
  };
};
var propagateSelection = ({
  store,
  selectionPropagation,
  newModel,
  oldModel,
  additionalItemsToPropagate
}) => {
  if (!selectionPropagation.descendants && !selectionPropagation.parents) {
    return newModel;
  }
  let shouldRegenerateModel = false;
  const newModelLookup = getLookupFromArray(newModel);
  const changes = getAddedAndRemovedItems({
    store,
    newModel,
    oldModel
  });
  additionalItemsToPropagate?.forEach((itemId) => {
    if (newModelLookup[itemId]) {
      if (!changes.added.includes(itemId)) {
        changes.added.push(itemId);
      }
    } else if (!changes.removed.includes(itemId)) {
      changes.removed.push(itemId);
    }
  });
  changes.added.forEach((addedItemId) => {
    if (selectionPropagation.descendants) {
      const selectDescendants = (itemId) => {
        if (itemId !== addedItemId) {
          shouldRegenerateModel = true;
          newModelLookup[itemId] = true;
        }
        itemsSelectors.itemOrderedChildrenIds(store.state, itemId).forEach(selectDescendants);
      };
      selectDescendants(addedItemId);
    }
    if (selectionPropagation.parents) {
      const checkAllDescendantsSelected = (itemId) => {
        if (!newModelLookup[itemId]) {
          return false;
        }
        const children = itemsSelectors.itemOrderedChildrenIds(store.state, itemId);
        return children.every(checkAllDescendantsSelected);
      };
      const selectParents = (itemId) => {
        const parentId = itemsSelectors.itemParentId(store.state, itemId);
        if (parentId == null) {
          return;
        }
        const siblings = itemsSelectors.itemOrderedChildrenIds(store.state, parentId);
        if (siblings.every(checkAllDescendantsSelected)) {
          shouldRegenerateModel = true;
          newModelLookup[parentId] = true;
          selectParents(parentId);
        }
      };
      selectParents(addedItemId);
    }
  });
  changes.removed.forEach((removedItemId) => {
    if (selectionPropagation.parents) {
      let parentId = itemsSelectors.itemParentId(store.state, removedItemId);
      while (parentId != null) {
        if (newModelLookup[parentId]) {
          shouldRegenerateModel = true;
          delete newModelLookup[parentId];
        }
        parentId = itemsSelectors.itemParentId(store.state, parentId);
      }
    }
    if (selectionPropagation.descendants) {
      const deSelectDescendants = (itemId) => {
        if (itemId !== removedItemId) {
          shouldRegenerateModel = true;
          delete newModelLookup[itemId];
        }
        itemsSelectors.itemOrderedChildrenIds(store.state, itemId).forEach(deSelectDescendants);
      };
      deSelectDescendants(removedItemId);
    }
  });
  return shouldRegenerateModel ? Object.keys(newModelLookup) : newModel;
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/itemPlugin.js
var selectorCheckboxSelectionStatus = createSelector2((state, itemId) => {
  if (selectionSelectors.isItemSelected(state, itemId)) {
    return "checked";
  }
  let hasSelectedDescendant = false;
  let hasUnSelectedDescendant = false;
  const traverseDescendants = (itemToTraverseId) => {
    if (itemToTraverseId !== itemId) {
      if (selectionSelectors.isItemSelected(state, itemToTraverseId)) {
        hasSelectedDescendant = true;
      } else {
        hasUnSelectedDescendant = true;
      }
    }
    itemsSelectors.itemOrderedChildrenIds(state, itemToTraverseId).forEach(traverseDescendants);
  };
  traverseDescendants(itemId);
  const shouldSelectBasedOnDescendants = selectionSelectors.propagationRules(state).parents;
  if (shouldSelectBasedOnDescendants) {
    if (hasSelectedDescendant && hasUnSelectedDescendant) {
      return "indeterminate";
    }
    if (hasSelectedDescendant && !hasUnSelectedDescendant) {
      return "checked";
    }
    return "empty";
  }
  if (hasSelectedDescendant) {
    return "indeterminate";
  }
  return "empty";
});
var useTreeViewSelectionItemPlugin = ({
  props
}) => {
  const {
    itemId
  } = props;
  const {
    store
  } = useTreeViewContext();
  const isCheckboxSelectionEnabled = useStore(store, selectionSelectors.isCheckboxSelectionEnabled);
  const isFeatureEnabledForItem = useStore(store, selectionSelectors.isFeatureEnabledForItem, itemId);
  const canItemBeSelected = useStore(store, selectionSelectors.canItemBeSelected, itemId);
  const selectionStatus = useStore(store, selectorCheckboxSelectionStatus, itemId);
  return {
    propsEnhancers: {
      root: () => {
        let ariaChecked;
        if (selectionStatus === "checked") {
          ariaChecked = true;
        } else if (selectionStatus === "indeterminate") {
          ariaChecked = "mixed";
        } else if (!canItemBeSelected) {
          ariaChecked = void 0;
        } else {
          ariaChecked = false;
        }
        return {
          "aria-checked": ariaChecked
        };
      },
      checkbox: ({
        externalEventHandlers,
        interactions
      }) => {
        const handleChange = (event) => {
          externalEventHandlers.onChange?.(event);
          if (event.defaultMuiPrevented) {
            return;
          }
          if (!selectionSelectors.canItemBeSelected(store.state, itemId)) {
            return;
          }
          interactions.handleCheckboxSelection(event);
        };
        return {
          tabIndex: -1,
          onChange: handleChange,
          visible: isCheckboxSelectionEnabled && isFeatureEnabledForItem,
          disabled: !canItemBeSelected,
          checked: selectionStatus === "checked",
          indeterminate: selectionStatus === "indeterminate"
        };
      }
    }
  };
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/useTreeViewSelection.js
var useTreeViewSelection = ({
  store,
  params
}) => {
  useAssertModelConsistency({
    componentName: "Tree View",
    propName: "selectedItems",
    controlled: params.selectedItems,
    defaultValue: params.defaultSelectedItems
  });
  const lastSelectedItem = React17.useRef(null);
  const lastSelectedRange = React17.useRef({});
  const setSelectedItems = (event, newModel, additionalItemsToPropagate) => {
    const oldModel = selectionSelectors.selectedItemsRaw(store.state);
    let cleanModel;
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(store.state);
    if (isMultiSelectEnabled && (params.selectionPropagation.descendants || params.selectionPropagation.parents)) {
      cleanModel = propagateSelection({
        store,
        selectionPropagation: params.selectionPropagation,
        newModel,
        oldModel,
        additionalItemsToPropagate
      });
    } else {
      cleanModel = newModel;
    }
    if (params.onItemSelectionToggle) {
      if (isMultiSelectEnabled) {
        const changes = getAddedAndRemovedItems({
          store,
          newModel: cleanModel,
          oldModel
        });
        if (params.onItemSelectionToggle) {
          changes.added.forEach((itemId) => {
            params.onItemSelectionToggle(event, itemId, true);
          });
          changes.removed.forEach((itemId) => {
            params.onItemSelectionToggle(event, itemId, false);
          });
        }
      } else if (params.onItemSelectionToggle && cleanModel !== oldModel) {
        if (oldModel != null) {
          params.onItemSelectionToggle(event, oldModel, false);
        }
        if (cleanModel != null) {
          params.onItemSelectionToggle(event, cleanModel, true);
        }
      }
    }
    if (params.selectedItems === void 0) {
      store.set("selection", _extends({}, store.state.selection, {
        selectedItems: cleanModel
      }));
    }
    params.onSelectedItemsChange?.(event, cleanModel);
  };
  const setItemSelection = ({
    itemId,
    event = null,
    keepExistingSelection = false,
    shouldBeSelected
  }) => {
    if (!selectionSelectors.enabled(store.state)) {
      return;
    }
    let newSelected;
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(store.state);
    if (keepExistingSelection) {
      const oldSelected = selectionSelectors.selectedItems(store.state);
      const isSelectedBefore = selectionSelectors.isItemSelected(store.state, itemId);
      if (isSelectedBefore && (shouldBeSelected === false || shouldBeSelected == null)) {
        newSelected = oldSelected.filter((id) => id !== itemId);
      } else if (!isSelectedBefore && (shouldBeSelected === true || shouldBeSelected == null)) {
        newSelected = [itemId].concat(oldSelected);
      } else {
        newSelected = oldSelected;
      }
    } else {
      if (shouldBeSelected === false || shouldBeSelected == null && selectionSelectors.isItemSelected(store.state, itemId)) {
        newSelected = isMultiSelectEnabled ? [] : null;
      } else {
        newSelected = isMultiSelectEnabled ? [itemId] : itemId;
      }
    }
    setSelectedItems(
      event,
      newSelected,
      // If shouldBeSelected === selectionSelectors.isItemSelected(store, itemId), we still want to propagate the select.
      // This is useful when the element is in an indeterminate state.
      [itemId]
    );
    lastSelectedItem.current = itemId;
    lastSelectedRange.current = {};
  };
  const selectRange = (event, [start, end]) => {
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(store.state);
    if (!isMultiSelectEnabled) {
      return;
    }
    let newSelectedItems = selectionSelectors.selectedItems(store.state).slice();
    if (Object.keys(lastSelectedRange.current).length > 0) {
      newSelectedItems = newSelectedItems.filter((id) => !lastSelectedRange.current[id]);
    }
    const selectedItemsLookup = getLookupFromArray(newSelectedItems);
    const range = getNonDisabledItemsInRange(store.state, start, end).filter((id) => itemsSelectors.isItemSelectable(store.state, id));
    const itemsToAddToModel = range.filter((id) => !selectedItemsLookup[id]);
    newSelectedItems = newSelectedItems.concat(itemsToAddToModel);
    setSelectedItems(event, newSelectedItems);
    lastSelectedRange.current = getLookupFromArray(range);
  };
  const expandSelectionRange = (event, itemId) => {
    if (lastSelectedItem.current != null) {
      const [start, end] = findOrderInTremauxTree(store.state, itemId, lastSelectedItem.current);
      selectRange(event, [start, end]);
    }
  };
  const selectRangeFromStartToItem = (event, itemId) => {
    selectRange(event, [getFirstNavigableItem(store.state), itemId]);
  };
  const selectRangeFromItemToEnd = (event, itemId) => {
    selectRange(event, [itemId, getLastNavigableItem(store.state)]);
  };
  const selectAllNavigableItems = (event) => {
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(store.state);
    if (!isMultiSelectEnabled) {
      return;
    }
    const navigableItems = getAllNavigableItems(store.state);
    setSelectedItems(event, navigableItems);
    lastSelectedRange.current = getLookupFromArray(navigableItems);
  };
  const selectItemFromArrowNavigation = (event, currentItem, nextItem) => {
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(store.state);
    if (!isMultiSelectEnabled) {
      return;
    }
    let newSelectedItems = selectionSelectors.selectedItems(store.state).slice();
    if (Object.keys(lastSelectedRange.current).length === 0) {
      newSelectedItems.push(nextItem);
      lastSelectedRange.current = {
        [currentItem]: true,
        [nextItem]: true
      };
    } else {
      if (!lastSelectedRange.current[currentItem]) {
        lastSelectedRange.current = {};
      }
      if (lastSelectedRange.current[nextItem]) {
        newSelectedItems = newSelectedItems.filter((id) => id !== currentItem);
        delete lastSelectedRange.current[currentItem];
      } else {
        newSelectedItems.push(nextItem);
        lastSelectedRange.current[nextItem] = true;
      }
    }
    setSelectedItems(event, newSelectedItems);
  };
  useIsoLayoutEffect(() => {
    store.set("selection", {
      selectedItems: params.selectedItems === void 0 ? store.state.selection.selectedItems : params.selectedItems,
      isEnabled: !params.disableSelection,
      isMultiSelectEnabled: params.multiSelect,
      isCheckboxSelectionEnabled: params.checkboxSelection,
      selectionPropagation: {
        descendants: params.selectionPropagation.descendants,
        parents: params.selectionPropagation.parents
      }
    });
  }, [store, params.selectedItems, params.multiSelect, params.checkboxSelection, params.disableSelection, params.selectionPropagation.descendants, params.selectionPropagation.parents]);
  return {
    getRootProps: () => ({
      "aria-multiselectable": params.multiSelect
    }),
    publicAPI: {
      setItemSelection
    },
    instance: {
      setItemSelection,
      selectAllNavigableItems,
      expandSelectionRange,
      selectRangeFromStartToItem,
      selectRangeFromItemToEnd,
      selectItemFromArrowNavigation
    }
  };
};
useTreeViewSelection.itemPlugin = useTreeViewSelectionItemPlugin;
var DEFAULT_SELECTED_ITEMS = [];
var EMPTY_SELECTION_PROPAGATION = {};
useTreeViewSelection.applyDefaultValuesToParams = ({
  params
}) => _extends({}, params, {
  disableSelection: params.disableSelection ?? false,
  multiSelect: params.multiSelect ?? false,
  checkboxSelection: params.checkboxSelection ?? false,
  defaultSelectedItems: params.defaultSelectedItems ?? (params.multiSelect ? DEFAULT_SELECTED_ITEMS : null),
  selectionPropagation: params.selectionPropagation ?? EMPTY_SELECTION_PROPAGATION
});
useTreeViewSelection.getInitialState = (params) => ({
  selection: {
    selectedItems: params.selectedItems === void 0 ? params.defaultSelectedItems : params.selectedItems,
    isEnabled: !params.disableSelection,
    isMultiSelectEnabled: params.multiSelect,
    isCheckboxSelectionEnabled: params.checkboxSelection,
    selectionPropagation: params.selectionPropagation
  }
});
useTreeViewSelection.params = {
  disableSelection: true,
  multiSelect: true,
  checkboxSelection: true,
  defaultSelectedItems: true,
  selectedItems: true,
  onSelectedItemsChange: true,
  onItemSelectionToggle: true,
  selectionPropagation: true
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewFocus/useTreeViewFocus.selectors.js
var defaultFocusableItemIdSelector = createSelectorMemoized(selectionSelectors.selectedItems, expansionSelectors.expandedItemsMap, itemsSelectors.itemMetaLookup, itemsSelectors.disabledItemFocusable, (state) => itemsSelectors.itemOrderedChildrenIds(state, null), (selectedItems, expandedItemsMap, itemMetaLookup, disabledItemsFocusable, orderedRootItemIds) => {
  const firstSelectedItem = selectedItems.find((itemId) => {
    if (!disabledItemsFocusable && isItemDisabled(itemMetaLookup, itemId)) {
      return false;
    }
    const itemMeta = itemMetaLookup[itemId];
    return itemMeta && (itemMeta.parentId == null || expandedItemsMap.has(itemMeta.parentId));
  });
  if (firstSelectedItem != null) {
    return firstSelectedItem;
  }
  const firstNavigableItem = orderedRootItemIds.find((itemId) => disabledItemsFocusable || !isItemDisabled(itemMetaLookup, itemId));
  if (firstNavigableItem != null) {
    return firstNavigableItem;
  }
  return null;
});
var focusSelectors = {
  /**
   * Gets the item that should be sequentially focusable (usually with the Tab key).
   * At any point in time, there is a single item that can be sequentially focused in the Tree View.
   * This item is the first selected item (that is both visible and navigable), if any, or the first navigable item if no item is selected.
   */
  defaultFocusableItemId: defaultFocusableItemIdSelector,
  /**
   * Checks whether an item is the default focusable item.
   */
  isItemTheDefaultFocusableItem: createSelector2(defaultFocusableItemIdSelector, (defaultFocusableItemId, itemId) => defaultFocusableItemId === itemId),
  /**
   * Gets the id of the item that is currently focused.
   */
  focusedItemId: createSelector2((state) => state.focus.focusedItemId),
  /**
   * Checks whether an item is focused.
   */
  isItemFocused: createSelector2((state, itemId) => state.focus.focusedItemId === itemId)
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewFocus/useTreeViewFocus.js
var useTreeViewFocus = ({
  instance,
  params,
  store
}) => {
  const setFocusedItemId = useStableCallback((itemId) => {
    const focusedItemId = focusSelectors.focusedItemId(store.state);
    if (focusedItemId === itemId) {
      return;
    }
    store.set("focus", _extends({}, store.state.focus, {
      focusedItemId: itemId
    }));
  });
  const isItemVisible = (itemId) => {
    const itemMeta = itemsSelectors.itemMeta(store.state, itemId);
    return itemMeta && (itemMeta.parentId == null || expansionSelectors.isItemExpanded(store.state, itemMeta.parentId));
  };
  const innerFocusItem = (event, itemId) => {
    const itemElement = instance.getItemDOMElement(itemId);
    if (itemElement) {
      itemElement.focus();
    }
    setFocusedItemId(itemId);
    if (params.onItemFocus) {
      params.onItemFocus(event, itemId);
    }
  };
  const focusItem = useStableCallback((event, itemId) => {
    if (isItemVisible(itemId)) {
      innerFocusItem(event, itemId);
    }
  });
  const removeFocusedItem = useStableCallback(() => {
    const focusedItemId = focusSelectors.focusedItemId(store.state);
    if (focusedItemId == null) {
      return;
    }
    const itemMeta = itemsSelectors.itemMeta(store.state, focusedItemId);
    if (itemMeta) {
      const itemElement = instance.getItemDOMElement(focusedItemId);
      if (itemElement) {
        itemElement.blur();
      }
    }
    setFocusedItemId(null);
  });
  useStoreEffect(store, itemsSelectors.itemMetaLookup, () => {
    const focusedItemId = focusSelectors.focusedItemId(store.state);
    if (focusedItemId == null) {
      return;
    }
    const hasItemBeenRemoved = !itemsSelectors.itemMeta(store.state, focusedItemId);
    if (!hasItemBeenRemoved) {
      return;
    }
    const defaultFocusableItemId = focusSelectors.defaultFocusableItemId(store.state);
    if (defaultFocusableItemId == null) {
      setFocusedItemId(null);
      return;
    }
    innerFocusItem(null, defaultFocusableItemId);
  });
  const createRootHandleFocus = (otherHandlers) => (event) => {
    otherHandlers.onFocus?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    const defaultFocusableItemId = focusSelectors.defaultFocusableItemId(store.state);
    if (event.target === event.currentTarget && defaultFocusableItemId != null) {
      innerFocusItem(event, defaultFocusableItemId);
    }
  };
  const createRootHandleBlur = (otherHandlers) => (event) => {
    otherHandlers.onBlur?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    setFocusedItemId(null);
  };
  return {
    getRootProps: (otherHandlers) => ({
      onFocus: createRootHandleFocus(otherHandlers),
      onBlur: createRootHandleBlur(otherHandlers)
    }),
    publicAPI: {
      focusItem
    },
    instance: {
      focusItem,
      removeFocusedItem
    }
  };
};
useTreeViewFocus.getInitialState = () => ({
  focus: {
    focusedItemId: null
  }
});
useTreeViewFocus.params = {
  onItemFocus: true
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewKeyboardNavigation/useTreeViewKeyboardNavigation.js
var React20 = __toESM(require_react(), 1);

// ../../node_modules/@base-ui/utils/esm/useOnMount.js
var React18 = __toESM(require_react(), 1);
var EMPTY = [];
function useOnMount2(fn) {
  React18.useEffect(fn, EMPTY);
}

// ../../node_modules/@base-ui/utils/esm/useTimeout.js
var EMPTY2 = 0;
var Timeout = class _Timeout {
  static create() {
    return new _Timeout();
  }
  currentId = EMPTY2;
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = EMPTY2;
      fn();
    }, delay);
  }
  isStarted() {
    return this.currentId !== EMPTY2;
  }
  clear = () => {
    if (this.currentId !== EMPTY2) {
      clearTimeout(this.currentId);
      this.currentId = EMPTY2;
    }
  };
  disposeEffect = () => {
    return this.clear;
  };
};
function useTimeout() {
  const timeout = useRefWithInit(Timeout.create).current;
  useOnMount2(timeout.disposeEffect);
  return timeout;
}

// ../../node_modules/@mui/x-tree-view/esm/internals/utils/plugins.js
var hasPlugin = (instance, plugin) => {
  const plugins = instance.getAvailablePlugins();
  return plugins.has(plugin);
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/itemPlugin.js
var React19 = __toESM(require_react(), 1);

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.selectors.js
var labelSelectors = {
  /**
   * Checks whether an item is editable.
   */
  isItemEditable: createSelector2((state) => state.label?.isItemEditable, itemsSelectors.itemModel, (isItemEditable, itemModel, _itemId) => {
    if (!itemModel || isItemEditable == null) {
      return false;
    }
    if (typeof isItemEditable === "boolean") {
      return isItemEditable;
    }
    return isItemEditable(itemModel);
  }),
  /**
   * Checks whether an item is being edited.
   */
  isItemBeingEdited: createSelector2((state, itemId) => itemId == null ? false : state.label?.editedItemId === itemId),
  /**
   * Checks whether any item is being edited.
   */
  isAnyItemBeingEdited: createSelector2((state) => !!state.label?.editedItemId)
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/itemPlugin.js
var useTreeViewLabelItemPlugin = ({
  props
}) => {
  const {
    store
  } = useTreeViewContext();
  const {
    label,
    itemId
  } = props;
  const [labelInputValue, setLabelInputValue] = React19.useState(label);
  const isItemEditable = useStore(store, labelSelectors.isItemEditable, itemId);
  const isItemBeingEdited = useStore(store, labelSelectors.isItemBeingEdited, itemId);
  React19.useEffect(() => {
    if (!isItemBeingEdited) {
      setLabelInputValue(label);
    }
  }, [isItemBeingEdited, label]);
  return {
    propsEnhancers: {
      label: () => ({
        editable: isItemEditable
      }),
      labelInput: ({
        externalEventHandlers,
        interactions
      }) => {
        if (!isItemEditable) {
          return {};
        }
        const handleKeydown = (event) => {
          externalEventHandlers.onKeyDown?.(event);
          if (event.defaultMuiPrevented) {
            return;
          }
          const target = event.target;
          if (event.key === "Enter" && target.value) {
            interactions.handleSaveItemLabel(event, target.value);
          } else if (event.key === "Escape") {
            interactions.handleCancelItemLabelEditing(event);
          }
        };
        const handleBlur = (event) => {
          externalEventHandlers.onBlur?.(event);
          if (event.defaultMuiPrevented) {
            return;
          }
          if (event.target.value) {
            interactions.handleSaveItemLabel(event, event.target.value);
          }
        };
        const handleInputChange = (event) => {
          externalEventHandlers.onChange?.(event);
          setLabelInputValue(event.target.value);
        };
        return {
          value: labelInputValue ?? "",
          "data-element": "labelInput",
          onChange: handleInputChange,
          onKeyDown: handleKeydown,
          onBlur: handleBlur,
          autoFocus: true,
          type: "text"
        };
      }
    }
  };
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.js
var useTreeViewLabel = ({
  store,
  params
}) => {
  const setEditedItem = (editedItemId) => {
    if (editedItemId !== null) {
      const isEditable = labelSelectors.isItemEditable(store.state, editedItemId);
      if (!isEditable) {
        return;
      }
    }
    store.set("label", _extends({}, store.state.label, {
      editedItemId
    }));
  };
  const updateItemLabel = (itemId, label) => {
    if (!label) {
      throw new Error(["MUI X: The Tree View component requires all items to have a `label` property.", "The label of an item cannot be empty.", itemId].join("\n"));
    }
    const item = store.state.items.itemMetaLookup[itemId];
    if (item.label === label) {
      return;
    }
    store.set("items", _extends({}, store.state.items, {
      itemMetaLookup: _extends({}, store.state.items.itemMetaLookup, {
        [itemId]: _extends({}, item, {
          label
        })
      })
    }));
    if (params.onItemLabelChange) {
      params.onItemLabelChange(itemId, label);
    }
  };
  useIsoLayoutEffect(() => {
    store.set("label", _extends({}, store.state.label, {
      isItemEditable: params.isItemEditable
    }));
  }, [store, params.isItemEditable]);
  return {
    instance: {
      setEditedItem,
      updateItemLabel
    },
    publicAPI: {
      setEditedItem,
      updateItemLabel
    }
  };
};
useTreeViewLabel.itemPlugin = useTreeViewLabelItemPlugin;
useTreeViewLabel.applyDefaultValuesToParams = ({
  params
}) => _extends({}, params, {
  isItemEditable: params.isItemEditable ?? false
});
useTreeViewLabel.getInitialState = (params) => ({
  label: {
    isItemEditable: params.isItemEditable,
    editedItemId: null
  }
});
useTreeViewLabel.params = {
  onItemLabelChange: true,
  isItemEditable: true
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewKeyboardNavigation/useTreeViewKeyboardNavigation.js
function isPrintableKey(string) {
  return !!string && string.length === 1 && !!string.match(/\S/);
}
var TYPEAHEAD_TIMEOUT = 500;
var useTreeViewKeyboardNavigation = ({
  instance,
  store,
  params
}) => {
  const isRtl = useRtl();
  const labelMap = React20.useRef({});
  const typeaheadQueryRef = React20.useRef("");
  const typeaheadTimeout = useTimeout();
  const updateLabelMap = useStableCallback((callback) => {
    labelMap.current = callback(labelMap.current);
  });
  const itemMetaLookup = useStore(store, itemsSelectors.itemMetaLookup);
  React20.useEffect(() => {
    if (instance.areItemUpdatesPrevented()) {
      return;
    }
    const newLabelMap = {};
    const processItem = (item) => {
      newLabelMap[item.id] = item.label.toLowerCase();
    };
    Object.values(itemMetaLookup).forEach(processItem);
    labelMap.current = newLabelMap;
  }, [itemMetaLookup, params.getItemId, instance]);
  const getNextItem = (itemIdToCheck) => {
    const nextItemId = getNextNavigableItem(store.state, itemIdToCheck);
    if (nextItemId === null) {
      return getFirstNavigableItem(store.state);
    }
    return nextItemId;
  };
  const getNextMatchingItemId = (itemId, query) => {
    let matchingItemId = null;
    const checkedItems = {};
    let currentItemId = query.length > 1 ? itemId : getNextItem(itemId);
    while (matchingItemId == null && !checkedItems[currentItemId]) {
      const itemLabel = labelMap.current[currentItemId];
      if (itemLabel?.startsWith(query)) {
        matchingItemId = currentItemId;
      } else {
        checkedItems[currentItemId] = true;
        currentItemId = getNextItem(currentItemId);
      }
    }
    return matchingItemId;
  };
  const getFirstMatchingItem = (itemId, newKey) => {
    const cleanNewKey = newKey.toLowerCase();
    const concatenatedQuery = `${typeaheadQueryRef.current}${cleanNewKey}`;
    const concatenatedQueryMatchingItemId = getNextMatchingItemId(itemId, concatenatedQuery);
    if (concatenatedQueryMatchingItemId != null) {
      typeaheadQueryRef.current = concatenatedQuery;
      return concatenatedQueryMatchingItemId;
    }
    const newKeyMatchingItemId = getNextMatchingItemId(itemId, cleanNewKey);
    if (newKeyMatchingItemId != null) {
      typeaheadQueryRef.current = cleanNewKey;
      return newKeyMatchingItemId;
    }
    typeaheadQueryRef.current = "";
    return null;
  };
  const canToggleItemSelection = (itemId) => selectionSelectors.canItemBeSelected(store.state, itemId);
  const canToggleItemExpansion = (itemId) => {
    return !itemsSelectors.isItemDisabled(store.state, itemId) && expansionSelectors.isItemExpandable(store.state, itemId);
  };
  const handleItemKeyDown = async (event, itemId) => {
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.altKey || isTargetInDescendants(event.target, event.currentTarget)) {
      return;
    }
    const ctrlPressed = event.ctrlKey || event.metaKey;
    const key = event.key;
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(store.state);
    switch (true) {
      // Select the item when pressing "Space"
      case (key === " " && canToggleItemSelection(itemId)): {
        event.preventDefault();
        if (isMultiSelectEnabled && event.shiftKey) {
          instance.expandSelectionRange(event, itemId);
        } else {
          instance.setItemSelection({
            event,
            itemId,
            keepExistingSelection: isMultiSelectEnabled,
            shouldBeSelected: void 0
          });
        }
        break;
      }
      // If the focused item has children, we expand it.
      // If the focused item has no children, we select it.
      case key === "Enter": {
        if (hasPlugin(instance, useTreeViewLabel) && labelSelectors.isItemEditable(store.state, itemId) && !labelSelectors.isItemBeingEdited(store.state, itemId)) {
          instance.setEditedItem(itemId);
        } else if (canToggleItemExpansion(itemId)) {
          instance.setItemExpansion({
            event,
            itemId
          });
          event.preventDefault();
        } else if (canToggleItemSelection(itemId)) {
          if (isMultiSelectEnabled) {
            event.preventDefault();
            instance.setItemSelection({
              event,
              itemId,
              keepExistingSelection: true
            });
          } else if (!selectionSelectors.isItemSelected(store.state, itemId)) {
            instance.setItemSelection({
              event,
              itemId
            });
            event.preventDefault();
          }
        }
        break;
      }
      // Focus the next focusable item
      case key === "ArrowDown": {
        const nextItem = getNextNavigableItem(store.state, itemId);
        if (nextItem) {
          event.preventDefault();
          instance.focusItem(event, nextItem);
          if (isMultiSelectEnabled && event.shiftKey && canToggleItemSelection(nextItem)) {
            instance.selectItemFromArrowNavigation(event, itemId, nextItem);
          }
        }
        break;
      }
      // Focuses the previous focusable item
      case key === "ArrowUp": {
        const previousItem = getPreviousNavigableItem(store.state, itemId);
        if (previousItem) {
          event.preventDefault();
          instance.focusItem(event, previousItem);
          if (isMultiSelectEnabled && event.shiftKey && canToggleItemSelection(previousItem)) {
            instance.selectItemFromArrowNavigation(event, itemId, previousItem);
          }
        }
        break;
      }
      // If the focused item is expanded, we move the focus to its first child
      // If the focused item is collapsed and has children, we expand it
      case (key === "ArrowRight" && !isRtl || key === "ArrowLeft" && isRtl): {
        if (ctrlPressed) {
          return;
        }
        if (expansionSelectors.isItemExpanded(store.state, itemId)) {
          const nextItemId = getNextNavigableItem(store.state, itemId);
          if (nextItemId) {
            instance.focusItem(event, nextItemId);
            event.preventDefault();
          }
        } else if (canToggleItemExpansion(itemId)) {
          instance.setItemExpansion({
            event,
            itemId
          });
          event.preventDefault();
        }
        break;
      }
      // If the focused item is expanded, we collapse it
      // If the focused item is collapsed and has a parent, we move the focus to this parent
      case (key === "ArrowLeft" && !isRtl || key === "ArrowRight" && isRtl): {
        if (ctrlPressed) {
          return;
        }
        if (canToggleItemExpansion(itemId) && expansionSelectors.isItemExpanded(store.state, itemId)) {
          instance.setItemExpansion({
            event,
            itemId
          });
          event.preventDefault();
        } else {
          const parent = itemsSelectors.itemParentId(store.state, itemId);
          if (parent) {
            instance.focusItem(event, parent);
            event.preventDefault();
          }
        }
        break;
      }
      // Focuses the first item in the tree
      case key === "Home": {
        if (canToggleItemSelection(itemId) && isMultiSelectEnabled && ctrlPressed && event.shiftKey) {
          instance.selectRangeFromStartToItem(event, itemId);
        } else {
          instance.focusItem(event, getFirstNavigableItem(store.state));
        }
        event.preventDefault();
        break;
      }
      // Focuses the last item in the tree
      case key === "End": {
        if (canToggleItemSelection(itemId) && isMultiSelectEnabled && ctrlPressed && event.shiftKey) {
          instance.selectRangeFromItemToEnd(event, itemId);
        } else {
          instance.focusItem(event, getLastNavigableItem(store.state));
        }
        event.preventDefault();
        break;
      }
      // Expand all siblings that are at the same level as the focused item
      case key === "*": {
        instance.expandAllSiblings(event, itemId);
        event.preventDefault();
        break;
      }
      // Multi select behavior when pressing Ctrl + a
      // Selects all the items
      case (String.fromCharCode(event.keyCode) === "A" && ctrlPressed && isMultiSelectEnabled && selectionSelectors.enabled(store.state)): {
        instance.selectAllNavigableItems(event);
        event.preventDefault();
        break;
      }
      // Type-ahead
      case (!ctrlPressed && !event.shiftKey && isPrintableKey(key)): {
        typeaheadTimeout.clear();
        const matchingItem = getFirstMatchingItem(itemId, key);
        if (matchingItem != null) {
          instance.focusItem(event, matchingItem);
          event.preventDefault();
        } else {
          typeaheadQueryRef.current = "";
        }
        typeaheadTimeout.start(TYPEAHEAD_TIMEOUT, () => {
          typeaheadQueryRef.current = "";
        });
        break;
      }
    }
  };
  return {
    instance: {
      updateLabelMap,
      handleItemKeyDown
    }
  };
};
useTreeViewKeyboardNavigation.params = {};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewJSXItems/useTreeViewJSXItems.js
var React23 = __toESM(require_react(), 1);

// ../../node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewChildrenItemProvider.js
var React21 = __toESM(require_react(), 1);
var import_prop_types = __toESM(require_prop_types(), 1);

// ../../node_modules/@mui/x-tree-view/esm/internals/utils/utils.js
function escapeOperandAttributeSelector(operand) {
  return operand.replace(/["\\]/g, "\\$&");
}

// ../../node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewChildrenItemProvider.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var TreeViewChildrenItemContext = React21.createContext(null);
if (true) TreeViewChildrenItemContext.displayName = "TreeViewChildrenItemContext";
function TreeViewChildrenItemProvider(props) {
  const {
    children,
    itemId = null,
    idAttribute
  } = props;
  const {
    instance,
    store,
    rootRef
  } = useTreeViewContext();
  const childrenIdAttrToIdRef = React21.useRef(/* @__PURE__ */ new Map());
  React21.useEffect(() => {
    if (!rootRef.current) {
      return;
    }
    const previousChildrenIds = itemsSelectors.itemOrderedChildrenIds(store.state, itemId ?? null) ?? [];
    const escapedIdAttr = escapeOperandAttributeSelector(idAttribute ?? rootRef.current.id);
    if (itemId != null) {
      const itemRoot = rootRef.current.querySelector(`*[id="${escapedIdAttr}"][role="treeitem"]`);
      if (itemRoot && itemRoot.getAttribute("aria-expanded") === "false") {
        return;
      }
    }
    const childrenElements = rootRef.current.querySelectorAll(`${itemId == null ? "" : `*[id="${escapedIdAttr}"] `}[role="treeitem"]:not(*[id="${escapedIdAttr}"] [role="treeitem"] [role="treeitem"])`);
    const childrenIds = Array.from(childrenElements).map((child) => childrenIdAttrToIdRef.current.get(child.id));
    const hasChanged = childrenIds.length !== previousChildrenIds.length || childrenIds.some((childId, index) => childId !== previousChildrenIds[index]);
    if (hasChanged) {
      instance.setJSXItemsOrderedChildrenIds(itemId ?? null, childrenIds);
    }
  });
  const value = React21.useMemo(() => ({
    registerChild: (childIdAttribute, childItemId) => childrenIdAttrToIdRef.current.set(childIdAttribute, childItemId),
    unregisterChild: (childIdAttribute) => childrenIdAttrToIdRef.current.delete(childIdAttribute),
    parentId: itemId
  }), [itemId]);
  return (0, import_jsx_runtime3.jsx)(TreeViewChildrenItemContext.Provider, {
    value,
    children
  });
}
true ? TreeViewChildrenItemProvider.propTypes = {
  children: import_prop_types.default.node,
  id: import_prop_types.default.string
} : void 0;

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewJSXItems/itemPlugin.js
var React22 = __toESM(require_react(), 1);

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLazyLoading/useTreeViewLazyLoading.selectors.js
var lazyLoadingSelectors = {
  /**
   * Gets the data source used to lazy load items.
   */
  dataSource: createSelector2((state) => state.lazyLoading?.dataSource),
  /**
   * Checks whether an item is loading.
   */
  isItemLoading: createSelector2((state, itemId) => state.lazyLoading?.dataSource.loading[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? false),
  /**
   * Checks whether an item has errors.
   */
  itemHasError: createSelector2((state, itemId) => !!state.lazyLoading?.dataSource.errors[itemId ?? TREE_VIEW_ROOT_PARENT_ID]),
  /**
   * Get an item error.
   */
  itemError: createSelector2((state, itemId) => state.lazyLoading?.dataSource.errors[itemId ?? TREE_VIEW_ROOT_PARENT_ID])
};

// ../../node_modules/@mui/x-tree-view/esm/hooks/useTreeItemUtils/useTreeItemUtils.js
var itemHasChildren = (reactChildren) => {
  if (Array.isArray(reactChildren)) {
    return reactChildren.length > 0 && reactChildren.some(itemHasChildren);
  }
  return Boolean(reactChildren);
};
var useTreeItemUtils = ({
  itemId,
  children
}) => {
  const {
    instance,
    store,
    publicAPI
  } = useTreeViewContext();
  const isItemExpandable = useStore(store, expansionSelectors.isItemExpandable, itemId);
  const isLoading = useStore(store, lazyLoadingSelectors.isItemLoading, itemId);
  const hasError = useStore(store, lazyLoadingSelectors.itemHasError, itemId);
  const isExpandable = itemHasChildren(children) || isItemExpandable;
  const isExpanded = useStore(store, expansionSelectors.isItemExpanded, itemId);
  const isFocused = useStore(store, focusSelectors.isItemFocused, itemId);
  const isSelected = useStore(store, selectionSelectors.isItemSelected, itemId);
  const isDisabled = useStore(store, itemsSelectors.isItemDisabled, itemId);
  const isEditing = useStore(store, labelSelectors.isItemBeingEdited, itemId);
  const isEditable = useStore(store, labelSelectors.isItemEditable, itemId);
  const status = {
    expandable: isExpandable,
    expanded: isExpanded,
    focused: isFocused,
    selected: isSelected,
    disabled: isDisabled,
    editing: isEditing,
    editable: isEditable,
    loading: isLoading,
    error: hasError
  };
  const handleExpansion = (event) => {
    if (status.disabled) {
      return;
    }
    if (!status.focused) {
      instance.focusItem(event, itemId);
    }
    const multiple = selectionSelectors.isMultiSelectEnabled(store.state) && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (status.expandable && !(multiple && expansionSelectors.isItemExpanded(store.state, itemId))) {
      instance.setItemExpansion({
        event,
        itemId
      });
    }
  };
  const handleSelection = (event) => {
    if (!selectionSelectors.canItemBeSelected(store.state, itemId)) {
      return;
    }
    if (!status.focused && !status.editing) {
      instance.focusItem(event, itemId);
    }
    const multiple = selectionSelectors.isMultiSelectEnabled(store.state) && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (multiple) {
      if (event.shiftKey) {
        instance.expandSelectionRange(event, itemId);
      } else {
        instance.setItemSelection({
          event,
          itemId,
          keepExistingSelection: true
        });
      }
    } else {
      instance.setItemSelection({
        event,
        itemId,
        shouldBeSelected: true
      });
    }
  };
  const handleCheckboxSelection = (event) => {
    const hasShift = event.nativeEvent.shiftKey;
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(store.state);
    if (isMultiSelectEnabled && hasShift) {
      instance.expandSelectionRange(event, itemId);
    } else {
      instance.setItemSelection({
        event,
        itemId,
        keepExistingSelection: isMultiSelectEnabled,
        shouldBeSelected: event.target.checked
      });
    }
  };
  const toggleItemEditing = () => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (isEditing) {
      instance.setEditedItem(null);
    } else {
      instance.setEditedItem(itemId);
    }
  };
  const handleSaveItemLabel = (event, newLabel) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (labelSelectors.isItemBeingEdited(store.state, itemId)) {
      instance.updateItemLabel(itemId, newLabel);
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  const handleCancelItemLabelEditing = (event) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (labelSelectors.isItemBeingEdited(store.state, itemId)) {
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  const interactions = {
    handleExpansion,
    handleSelection,
    handleCheckboxSelection,
    toggleItemEditing,
    handleSaveItemLabel,
    handleCancelItemLabelEditing
  };
  return {
    interactions,
    status,
    publicAPI
  };
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewJSXItems/itemPlugin.js
var useTreeViewJSXItemsItemPlugin = ({
  props,
  rootRef,
  contentRef
}) => {
  const {
    instance,
    store
  } = useTreeViewContext();
  const {
    children,
    disabled = false,
    disableSelection = false,
    label,
    itemId,
    id
  } = props;
  const parentContext = React22.useContext(TreeViewChildrenItemContext);
  if (parentContext == null) {
    throw new Error(["MUI X: Could not find the Tree View Children Item context.", "It looks like you rendered your component outside of a SimpleTreeView parent component.", "This can also happen if you are bundling multiple versions of the Tree View."].join("\n"));
  }
  const {
    registerChild,
    unregisterChild,
    parentId
  } = parentContext;
  const expandable = itemHasChildren(children);
  const pluginContentRef = React22.useRef(null);
  const handleContentRef = useMergedRefs(pluginContentRef, contentRef);
  const treeId = useStore(store, idSelectors.treeId);
  useIsoLayoutEffect(() => {
    const idAttribute = generateTreeItemIdAttribute({
      itemId,
      treeId,
      id
    });
    registerChild(idAttribute, itemId);
    return () => {
      unregisterChild(idAttribute);
      unregisterChild(idAttribute);
    };
  }, [store, instance, registerChild, unregisterChild, itemId, id, treeId]);
  useIsoLayoutEffect(() => {
    return instance.insertJSXItem({
      id: itemId,
      idAttribute: id,
      parentId,
      expandable,
      disabled,
      selectable: !disableSelection
    });
  }, [instance, parentId, itemId, expandable, disabled, disableSelection, id]);
  React22.useEffect(() => {
    if (label) {
      return instance.mapLabelFromJSX(itemId, (pluginContentRef.current?.textContent ?? "").toLowerCase());
    }
    return void 0;
  }, [instance, itemId, label]);
  return {
    contentRef: handleContentRef,
    rootRef
  };
};

// ../../node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewJSXItems/useTreeViewJSXItems.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var useTreeViewJSXItems = ({
  instance,
  store
}) => {
  instance.preventItemUpdates();
  const insertJSXItem = useStableCallback((item) => {
    if (store.state.items.itemMetaLookup[item.id] != null) {
      throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", `Two items were provided with the same id in the \`items\` prop: "${item.id}"`].join("\n"));
    }
    store.set("items", _extends({}, store.state.items, {
      itemMetaLookup: _extends({}, store.state.items.itemMetaLookup, {
        [item.id]: item
      }),
      // For Simple Tree View, we don't have a proper `item` object, so we create a very basic one.
      itemModelLookup: _extends({}, store.state.items.itemModelLookup, {
        [item.id]: {
          id: item.id,
          label: item.label ?? ""
        }
      })
    }));
    return () => {
      const newItemMetaLookup = _extends({}, store.state.items.itemMetaLookup);
      const newItemModelLookup = _extends({}, store.state.items.itemModelLookup);
      delete newItemMetaLookup[item.id];
      delete newItemModelLookup[item.id];
      store.set("items", _extends({}, store.state.items, {
        itemMetaLookup: newItemMetaLookup,
        itemModelLookup: newItemModelLookup
      }));
    };
  });
  const setJSXItemsOrderedChildrenIds = (parentId, orderedChildrenIds) => {
    const parentIdWithDefault = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    store.set("items", _extends({}, store.state.items, {
      itemOrderedChildrenIdsLookup: _extends({}, store.state.items.itemOrderedChildrenIdsLookup, {
        [parentIdWithDefault]: orderedChildrenIds
      }),
      itemChildrenIndexesLookup: _extends({}, store.state.items.itemChildrenIndexesLookup, {
        [parentIdWithDefault]: buildSiblingIndexes(orderedChildrenIds)
      })
    }));
  };
  const mapLabelFromJSX = useStableCallback((itemId, label) => {
    instance.updateLabelMap((labelMap) => {
      labelMap[itemId] = label;
      return labelMap;
    });
    return () => {
      instance.updateLabelMap((labelMap) => {
        const newMap = _extends({}, labelMap);
        delete newMap[itemId];
        return newMap;
      });
    };
  });
  return {
    instance: {
      insertJSXItem,
      setJSXItemsOrderedChildrenIds,
      mapLabelFromJSX
    }
  };
};
useTreeViewJSXItems.itemPlugin = useTreeViewJSXItemsItemPlugin;
useTreeViewJSXItems.wrapItem = ({
  children,
  itemId,
  idAttribute
}) => {
  const depthContext = React23.useContext(TreeViewItemDepthContext);
  return (0, import_jsx_runtime4.jsx)(TreeViewChildrenItemProvider, {
    itemId,
    idAttribute,
    children: (0, import_jsx_runtime4.jsx)(TreeViewItemDepthContext.Provider, {
      value: depthContext + 1,
      children
    })
  });
};
if (true) useTreeViewJSXItems.wrapItem.displayName = "useTreeViewJSXItems.wrapItem";
useTreeViewJSXItems.wrapRoot = ({
  children
}) => (0, import_jsx_runtime4.jsx)(TreeViewChildrenItemProvider, {
  itemId: null,
  idAttribute: null,
  children: (0, import_jsx_runtime4.jsx)(TreeViewItemDepthContext.Provider, {
    value: 0,
    children
  })
});
if (true) useTreeViewJSXItems.wrapRoot.displayName = "useTreeViewJSXItems.wrapRoot";
useTreeViewJSXItems.params = {};

// ../../node_modules/@mui/x-tree-view/esm/SimpleTreeView/SimpleTreeView.plugins.js
var SIMPLE_TREE_VIEW_PLUGINS = [useTreeViewItems, useTreeViewExpansion, useTreeViewSelection, useTreeViewFocus, useTreeViewKeyboardNavigation, useTreeViewJSXItems];

// ../../node_modules/@mui/x-tree-view/esm/SimpleTreeView/SimpleTreeView.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var _excluded2 = ["slots", "slotProps"];
var useThemeProps2 = createUseThemeProps("MuiSimpleTreeView");
var useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  return React24.useMemo(() => {
    const slots = {
      root: ["root"],
      item: ["item"],
      itemContent: ["itemContent"],
      itemGroupTransition: ["itemGroupTransition"],
      itemIconContainer: ["itemIconContainer"],
      itemLabel: ["itemLabel"],
      // itemLabelInput: ['itemLabelInput'], => feature not available on this component
      itemCheckbox: ["itemCheckbox"]
      // itemDragAndDropOverlay: ['itemDragAndDropOverlay'], => feature not available on this component
      // itemErrorIcon: ['itemErrorIcon'], => feature not available on this component
    };
    return composeClasses(slots, getSimpleTreeViewUtilityClass, classes);
  }, [classes]);
};
var SimpleTreeViewRoot = styled_default("ul", {
  name: "MuiSimpleTreeView",
  slot: "Root"
})({
  padding: 0,
  margin: 0,
  listStyle: "none",
  outline: 0,
  position: "relative"
});
var EMPTY_ITEMS = [];
var SimpleTreeView = React24.forwardRef(function SimpleTreeView2(inProps, ref) {
  const props = useThemeProps2({
    props: inProps,
    name: "MuiSimpleTreeView"
  });
  const {
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  if (true) {
    if (props.items != null) {
      warnOnce(["MUI X: The Simple Tree View component does not support the `items` prop.", "If you want to add items, you need to pass them as JSX children.", "Check the documentation for more details: https://mui.com/x/react-tree-view/simple-tree-view/items/."]);
    }
  }
  const {
    getRootProps,
    contextValue
  } = useTreeView({
    plugins: SIMPLE_TREE_VIEW_PLUGINS,
    rootRef: ref,
    props: _extends({}, other, {
      items: EMPTY_ITEMS
    })
  });
  const classes = useUtilityClasses(props);
  const Root = slots?.root ?? SimpleTreeViewRoot;
  const rootProps = useSlotProps_default({
    elementType: Root,
    externalSlotProps: slotProps?.root,
    className: classes.root,
    getSlotProps: getRootProps,
    ownerState: props
  });
  return (0, import_jsx_runtime5.jsx)(TreeViewProvider, {
    contextValue,
    classes,
    slots,
    slotProps,
    children: (0, import_jsx_runtime5.jsx)(Root, _extends({}, rootProps))
  });
});
if (true) SimpleTreeView.displayName = "SimpleTreeView";
true ? SimpleTreeView.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The ref object that allows Tree View manipulation. Can be instantiated with `useSimpleTreeViewApiRef()`.
   */
  apiRef: import_prop_types2.default.shape({
    current: import_prop_types2.default.shape({
      focusItem: import_prop_types2.default.func,
      getItem: import_prop_types2.default.func,
      getItemDOMElement: import_prop_types2.default.func,
      getItemOrderedChildrenIds: import_prop_types2.default.func,
      getItemTree: import_prop_types2.default.func,
      getParentId: import_prop_types2.default.func,
      isItemExpanded: import_prop_types2.default.func,
      setIsItemDisabled: import_prop_types2.default.func,
      setItemExpansion: import_prop_types2.default.func,
      setItemSelection: import_prop_types2.default.func
    })
  }),
  /**
   * Whether the Tree View renders a checkbox at the left of its label that allows selecting it.
   * @default false
   */
  checkboxSelection: import_prop_types2.default.bool,
  /**
   * The content of the component.
   */
  children: import_prop_types2.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types2.default.object,
  className: import_prop_types2.default.string,
  /**
   * Expanded item ids.
   * Used when the item's expansion is not controlled.
   * @default []
   */
  defaultExpandedItems: import_prop_types2.default.arrayOf(import_prop_types2.default.string),
  /**
   * Selected item ids. (Uncontrolled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   * @default []
   */
  defaultSelectedItems: import_prop_types2.default.any,
  /**
   * Whether the items should be focusable when disabled.
   * @default false
   */
  disabledItemsFocusable: import_prop_types2.default.bool,
  /**
   * Whether selection is disabled.
   * @default false
   */
  disableSelection: import_prop_types2.default.bool,
  /**
   * Expanded item ids.
   * Used when the item's expansion is controlled.
   */
  expandedItems: import_prop_types2.default.arrayOf(import_prop_types2.default.string),
  /**
   * The slot that triggers the item's expansion when clicked.
   * @default 'content'
   */
  expansionTrigger: import_prop_types2.default.oneOf(["content", "iconContainer"]),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types2.default.string,
  /**
   * Horizontal indentation between an item and its children.
   * Examples: 24, "24px", "2rem", "2em".
   * @default 12px
   */
  itemChildrenIndentation: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string]),
  /**
   * Whether multiple items can be selected.
   * @default false
   */
  multiSelect: import_prop_types2.default.bool,
  /**
   * Callback fired when Tree Items are expanded/collapsed.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemExpansion()` method.
   * @param {TreeViewItemId[]} itemIds The ids of the expanded items.
   */
  onExpandedItemsChange: import_prop_types2.default.func,
  /**
   * Callback fired when the `content` slot of a given Tree Item is clicked.
   * @param {React.MouseEvent} event The DOM event that triggered the change.
   * @param {TreeViewItemId} itemId The id of the focused item.
   */
  onItemClick: import_prop_types2.default.func,
  /**
   * Callback fired when a Tree Item is expanded or collapsed.
   * @param {React.SyntheticEvent | null} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemExpansion()` method.
   * @param {TreeViewItemId} itemId The itemId of the modified item.
   * @param {boolean} isExpanded `true` if the item has just been expanded, `false` if it has just been collapsed.
   */
  onItemExpansionToggle: import_prop_types2.default.func,
  /**
   * Callback fired when a given Tree Item is focused.
   * @param {React.SyntheticEvent | null} event The DOM event that triggered the change. **Warning**: This is a generic event not a focus event.
   * @param {TreeViewItemId} itemId The id of the focused item.
   */
  onItemFocus: import_prop_types2.default.func,
  /**
   * Callback fired when a Tree Item is selected or deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemSelection()` method.
   * @param {TreeViewItemId} itemId The itemId of the modified item.
   * @param {boolean} isSelected `true` if the item has just been selected, `false` if it has just been deselected.
   */
  onItemSelectionToggle: import_prop_types2.default.func,
  /**
   * Callback fired when Tree Items are selected/deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemSelection()` method.
   * @param {TreeViewItemId[] | TreeViewItemId} itemIds The ids of the selected items.
   * When `multiSelect` is `true`, this is an array of strings; when false (default) a string.
   */
  onSelectedItemsChange: import_prop_types2.default.func,
  /**
   * Selected item ids. (Controlled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   */
  selectedItems: import_prop_types2.default.any,
  /**
   * When `selectionPropagation.descendants` is set to `true`.
   *
   * - Selecting a parent selects all its descendants automatically.
   * - Deselecting a parent deselects all its descendants automatically.
   *
   * When `selectionPropagation.parents` is set to `true`.
   *
   * - Selecting all the descendants of a parent selects the parent automatically.
   * - Deselecting a descendant of a selected parent deselects the parent automatically.
   *
   * Only works when `multiSelect` is `true`.
   * On the <SimpleTreeView />, only the expanded items are considered (since the collapsed item are not passed to the Tree View component at all)
   *
   * @default { parents: false, descendants: false }
   */
  selectionPropagation: import_prop_types2.default.shape({
    descendants: import_prop_types2.default.bool,
    parents: import_prop_types2.default.bool
  }),
  /**
   * The props used for each component slot.
   */
  slotProps: import_prop_types2.default.object,
  /**
   * Overridable component slots.
   */
  slots: import_prop_types2.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object])
} : void 0;

// ../../node_modules/@mui/x-tree-view/esm/RichTreeView/RichTreeView.js
var React30 = __toESM(require_react(), 1);
var import_prop_types7 = __toESM(require_prop_types(), 1);

// ../../node_modules/@mui/x-tree-view/esm/RichTreeView/richTreeViewClasses.js
function getRichTreeViewUtilityClass(slot) {
  return generateUtilityClass("MuiRichTreeView", slot);
}
var richTreeViewClasses = generateUtilityClasses("MuiRichTreeView", ["root", "item", "itemContent", "itemGroupTransition", "itemIconContainer", "itemLabel", "itemCheckbox", "itemLabelInput"]);

// ../../node_modules/@mui/x-tree-view/esm/RichTreeView/RichTreeView.plugins.js
var RICH_TREE_VIEW_PLUGINS = [useTreeViewItems, useTreeViewExpansion, useTreeViewSelection, useTreeViewFocus, useTreeViewKeyboardNavigation, useTreeViewLabel];

// ../../node_modules/@mui/x-tree-view/esm/internals/components/RichTreeViewItems.js
var React29 = __toESM(require_react(), 1);

// ../../node_modules/@mui/x-internals/esm/fastObjectShallowCompare/fastObjectShallowCompare.js
var is = Object.is;
function fastObjectShallowCompare(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a instanceof Object) || !(b instanceof Object)) {
    return false;
  }
  let aLength = 0;
  let bLength = 0;
  for (const key in a) {
    aLength += 1;
    if (!is(a[key], b[key])) {
      return false;
    }
    if (!(key in b)) {
      return false;
    }
  }
  for (const _ in b) {
    bLength += 1;
  }
  return aLength === bLength;
}

// ../../node_modules/@mui/x-tree-view/esm/TreeItem/TreeItem.js
var React28 = __toESM(require_react(), 1);
var import_prop_types6 = __toESM(require_prop_types(), 1);

// ../../node_modules/@mui/x-tree-view/esm/useTreeItem/useTreeItem.js
var React25 = __toESM(require_react(), 1);
var depthSelector = (state, itemId, depthContext) => {
  if (typeof depthContext === "function") {
    return depthContext(state, itemId);
  }
  return depthContext;
};
var useTreeItem = (parameters) => {
  const {
    runItemPlugins,
    instance,
    publicAPI,
    store
  } = useTreeViewContext();
  const depthContext = React25.useContext(TreeViewItemDepthContext);
  const depth = useStore(store, depthSelector, parameters.itemId, depthContext);
  const {
    id,
    itemId,
    label,
    children,
    rootRef
  } = parameters;
  const {
    rootRef: pluginRootRef,
    contentRef,
    propsEnhancers
  } = runItemPlugins(parameters);
  const {
    interactions,
    status
  } = useTreeItemUtils({
    itemId,
    children
  });
  const rootRefObject = React25.useRef(null);
  const contentRefObject = React25.useRef(null);
  const handleRootRef = useMergedRefs(rootRef, pluginRootRef, rootRefObject);
  const handleContentRef = useMergedRefs(contentRef, contentRefObject);
  const checkboxRef = React25.useRef(null);
  const treeId = useStore(store, idSelectors.treeId);
  const isCheckboxSelectionEnabled = useStore(store, selectionSelectors.isCheckboxSelectionEnabled);
  const idAttribute = generateTreeItemIdAttribute({
    itemId,
    treeId,
    id
  });
  const shouldBeAccessibleWithTab = useStore(store, focusSelectors.isItemTheDefaultFocusableItem, itemId);
  const sharedPropsEnhancerParams = {
    rootRefObject,
    contentRefObject,
    interactions
  };
  const createRootHandleFocus = (otherHandlers) => (event) => {
    otherHandlers.onFocus?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (!status.focused && itemsSelectors.canItemBeFocused(store.state, itemId) && event.currentTarget === event.target) {
      instance.focusItem(event, itemId);
    }
  };
  const createRootHandleBlur = (otherHandlers) => (event) => {
    otherHandlers.onBlur?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    const rootElement = instance.getItemDOMElement(itemId);
    if (status.editing || // we can exit the editing state by clicking outside the input (within the Tree Item) or by pressing Enter or Escape -> we don't want to remove the focused item from the state in these cases
    // we can also exit the editing state by clicking on the root itself -> want to remove the focused item from the state in this case
    event.relatedTarget && isTargetInDescendants(event.relatedTarget, rootElement) && (event.target && event.target?.dataset?.element === "labelInput" && isTargetInDescendants(event.target, rootElement) || event.relatedTarget?.dataset?.element === "labelInput")) {
      return;
    }
    instance.removeFocusedItem();
  };
  const createRootHandleKeyDown = (otherHandlers) => (event) => {
    otherHandlers.onKeyDown?.(event);
    if (event.defaultMuiPrevented || event.target?.dataset?.element === "labelInput") {
      return;
    }
    instance.handleItemKeyDown(event, itemId);
  };
  const createLabelHandleDoubleClick = (otherHandlers) => (event) => {
    otherHandlers.onDoubleClick?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    interactions.toggleItemEditing();
  };
  const createContentHandleClick = (otherHandlers) => (event) => {
    otherHandlers.onClick?.(event);
    instance.handleItemClick(event, itemId);
    if (event.defaultMuiPrevented || checkboxRef.current?.contains(event.target)) {
      return;
    }
    if (expansionSelectors.triggerSlot(store.state) === "content") {
      interactions.handleExpansion(event);
    }
    if (!isCheckboxSelectionEnabled) {
      interactions.handleSelection(event);
    }
  };
  const createContentHandleMouseDown = (otherHandlers) => (event) => {
    otherHandlers.onMouseDown?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.shiftKey || event.ctrlKey || event.metaKey || status.disabled) {
      event.preventDefault();
    }
  };
  const createIconContainerHandleClick = (otherHandlers) => (event) => {
    otherHandlers.onClick?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (expansionSelectors.triggerSlot(store.state) === "iconContainer") {
      interactions.handleExpansion(event);
    }
  };
  const getContextProviderProps = () => ({
    itemId,
    id
  });
  const getRootProps = (externalProps = {}) => {
    const externalEventHandlers = _extends({}, extractEventHandlers_default(parameters), extractEventHandlers_default(externalProps));
    const props = _extends({}, externalEventHandlers, {
      ref: handleRootRef,
      role: "treeitem",
      tabIndex: shouldBeAccessibleWithTab ? 0 : -1,
      id: idAttribute,
      "aria-expanded": status.expandable ? status.expanded : void 0,
      "aria-disabled": status.disabled || void 0
    }, externalProps, {
      style: _extends({}, externalProps.style ?? {}, {
        "--TreeView-itemDepth": depth
      }),
      onFocus: createRootHandleFocus(externalEventHandlers),
      onBlur: createRootHandleBlur(externalEventHandlers),
      onKeyDown: createRootHandleKeyDown(externalEventHandlers)
    });
    const enhancedRootProps = propsEnhancers.root?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, props, enhancedRootProps);
  };
  const getContentProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const props = _extends({}, externalEventHandlers, externalProps, {
      ref: handleContentRef,
      onClick: createContentHandleClick(externalEventHandlers),
      onMouseDown: createContentHandleMouseDown(externalEventHandlers),
      status
    });
    ["expanded", "selected", "focused", "disabled", "editing", "editable"].forEach((key) => {
      if (status[key]) {
        props[`data-${key}`] = "";
      }
    });
    const enhancedContentProps = propsEnhancers.content?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, props, enhancedContentProps);
  };
  const getCheckboxProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const props = _extends({}, externalEventHandlers, {
      ref: checkboxRef,
      "aria-hidden": true
    }, externalProps);
    const enhancedCheckboxProps = propsEnhancers.checkbox?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, props, enhancedCheckboxProps);
  };
  const getLabelProps = (externalProps = {}) => {
    const externalEventHandlers = _extends({}, extractEventHandlers_default(externalProps));
    const props = _extends({}, externalEventHandlers, {
      children: label
    }, externalProps, {
      onDoubleClick: createLabelHandleDoubleClick(externalEventHandlers)
    });
    const enhancedLabelProps = propsEnhancers.label?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, enhancedLabelProps, props);
  };
  const getLabelInputProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const enhancedLabelInputProps = propsEnhancers.labelInput?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, externalProps, enhancedLabelInputProps);
  };
  const getIconContainerProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    return _extends({}, externalEventHandlers, externalProps, {
      onClick: createIconContainerHandleClick(externalEventHandlers)
    });
  };
  const getErrorContainerProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    return _extends({}, externalEventHandlers, externalProps);
  };
  const getLoadingContainerProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    return _extends({
      size: "12px",
      thickness: 6
    }, externalEventHandlers, externalProps);
  };
  const getGroupTransitionProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const response = _extends({}, externalEventHandlers, {
      unmountOnExit: true,
      component: "ul",
      role: "group",
      in: status.expanded,
      children
    }, externalProps);
    return response;
  };
  const getDragAndDropOverlayProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const enhancedDragAndDropOverlayProps = propsEnhancers.dragAndDropOverlay?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, externalProps, enhancedDragAndDropOverlayProps);
  };
  return {
    getContextProviderProps,
    getRootProps,
    getContentProps,
    getGroupTransitionProps,
    getIconContainerProps,
    getCheckboxProps,
    getLabelProps,
    getLabelInputProps,
    getDragAndDropOverlayProps,
    getErrorContainerProps,
    getLoadingContainerProps,
    rootRef: handleRootRef,
    status,
    publicAPI
  };
};

// ../../node_modules/@mui/x-tree-view/esm/TreeItem/treeItemClasses.js
function getTreeItemUtilityClass(slot) {
  return generateUtilityClass("MuiTreeItem", slot);
}
var treeItemClasses = generateUtilityClasses("MuiTreeItem", [
  "root",
  "content",
  "groupTransition",
  "iconContainer",
  "label",
  "checkbox",
  "labelInput",
  "dragAndDropOverlay",
  "errorIcon",
  "loadingIcon",
  // State classes, will be replaced by data-attrs in the next major
  "expanded",
  "selected",
  "focused",
  "disabled",
  "editable",
  "editing"
]);

// ../../node_modules/@mui/x-tree-view/esm/TreeItemIcon/TreeItemIcon.js
var React26 = __toESM(require_react(), 1);
var import_prop_types3 = __toESM(require_prop_types(), 1);

// ../../node_modules/@mui/x-tree-view/esm/icons/icons.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var TreeViewExpandIcon = createSvgIcon((0, import_jsx_runtime6.jsx)("path", {
  d: "M10 6 8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
}), "TreeViewExpandIcon");
var TreeViewCollapseIcon = createSvgIcon((0, import_jsx_runtime6.jsx)("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "TreeViewCollapseIcon");

// ../../node_modules/@mui/x-tree-view/esm/TreeItemIcon/TreeItemIcon.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var _excluded3 = ["ownerState"];
function pickIcon(treeItemIcon, treeViewIcon, fallback) {
  if (treeItemIcon !== void 0) {
    return treeItemIcon;
  }
  if (treeViewIcon !== void 0) {
    return treeViewIcon;
  }
  return fallback;
}
function TreeItemIcon(props) {
  const {
    slots: slotsFromTreeItem,
    slotProps: slotPropsFromTreeItem,
    status
  } = props;
  const {
    slots: slotsFromTreeView,
    slotProps: slotPropsFromTreeView
  } = useTreeViewStyleContext();
  const slots = {
    collapseIcon: pickIcon(slotsFromTreeItem?.collapseIcon, slotsFromTreeView.collapseIcon, TreeViewCollapseIcon),
    expandIcon: pickIcon(slotsFromTreeItem?.expandIcon, slotsFromTreeView.expandIcon, TreeViewExpandIcon),
    endIcon: pickIcon(slotsFromTreeItem?.endIcon, slotsFromTreeView.endIcon),
    icon: slotsFromTreeItem?.icon
  };
  let iconName;
  if (slots?.icon) {
    iconName = "icon";
  } else if (status.expandable) {
    if (status.expanded) {
      iconName = "collapseIcon";
    } else {
      iconName = "expandIcon";
    }
  } else {
    iconName = "endIcon";
  }
  const Icon = slots[iconName];
  const _useSlotProps = useSlotProps_default({
    elementType: Icon,
    externalSlotProps: (tempOwnerState) => _extends({}, resolveComponentProps_default(slotPropsFromTreeView[iconName], tempOwnerState), resolveComponentProps_default(slotPropsFromTreeItem?.[iconName], tempOwnerState)),
    // TODO: Add proper ownerState
    ownerState: {}
  }), iconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded3);
  if (!Icon) {
    return null;
  }
  return (0, import_jsx_runtime7.jsx)(Icon, _extends({}, iconProps));
}
true ? TreeItemIcon.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types3.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types3.default.object,
  status: import_prop_types3.default.shape({
    disabled: import_prop_types3.default.bool.isRequired,
    editable: import_prop_types3.default.bool.isRequired,
    editing: import_prop_types3.default.bool.isRequired,
    error: import_prop_types3.default.bool.isRequired,
    expandable: import_prop_types3.default.bool.isRequired,
    expanded: import_prop_types3.default.bool.isRequired,
    focused: import_prop_types3.default.bool.isRequired,
    loading: import_prop_types3.default.bool.isRequired,
    selected: import_prop_types3.default.bool.isRequired
  }).isRequired
} : void 0;

// ../../node_modules/@mui/x-tree-view/esm/TreeItemDragAndDropOverlay/TreeItemDragAndDropOverlay.js
var import_prop_types4 = __toESM(require_prop_types(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var TreeItemDragAndDropOverlayRoot = styled_default("div", {
  name: "MuiTreeItemDragAndDropOverlay",
  slot: "Root",
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "action"
})(({
  theme
}) => ({
  position: "absolute",
  left: 0,
  display: "flex",
  top: 0,
  bottom: 0,
  right: 0,
  pointerEvents: "none",
  variants: [{
    props: {
      action: "make-child"
    },
    style: {
      marginLeft: "calc(var(--TreeView-indentMultiplier) * var(--TreeView-itemDepth))",
      borderRadius: theme.shape.borderRadius,
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.darkChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.dark, theme.palette.action.focusOpacity)
    }
  }, {
    props: {
      action: "reorder-above"
    },
    style: {
      marginLeft: "calc(var(--TreeView-indentMultiplier) * var(--TreeView-itemDepth))",
      borderTop: `1px solid ${(theme.vars || theme).palette.action.active}`
    }
  }, {
    props: {
      action: "reorder-below"
    },
    style: {
      marginLeft: "calc(var(--TreeView-indentMultiplier) * var(--TreeView-itemDepth))",
      borderBottom: `1px solid ${(theme.vars || theme).palette.action.active}`
    }
  }, {
    props: {
      action: "move-to-parent"
    },
    style: {
      marginLeft: "calc(var(--TreeView-indentMultiplier) * calc(var(--TreeView-itemDepth) - 1))",
      borderBottom: `1px solid ${(theme.vars || theme).palette.action.active}`
    }
  }]
}));
function TreeItemDragAndDropOverlay(props) {
  if (props.action == null) {
    return null;
  }
  return (0, import_jsx_runtime8.jsx)(TreeItemDragAndDropOverlayRoot, _extends({}, props));
}
true ? TreeItemDragAndDropOverlay.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  action: import_prop_types4.default.oneOf(["make-child", "move-to-parent", "reorder-above", "reorder-below"]),
  style: import_prop_types4.default.object
} : void 0;

// ../../node_modules/@mui/x-tree-view/esm/TreeItemProvider/TreeItemProvider.js
var React27 = __toESM(require_react(), 1);
var import_prop_types5 = __toESM(require_prop_types(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
function TreeItemProvider(props) {
  const {
    children,
    itemId,
    id
  } = props;
  const {
    wrapItem,
    instance,
    store
  } = useTreeViewContext();
  const treeId = useStore(store, idSelectors.treeId);
  const idAttribute = generateTreeItemIdAttribute({
    itemId,
    treeId,
    id
  });
  return (0, import_jsx_runtime9.jsx)(React27.Fragment, {
    children: wrapItem({
      children,
      itemId,
      instance,
      idAttribute
    })
  });
}
true ? TreeItemProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types5.default.node,
  id: import_prop_types5.default.string,
  itemId: import_prop_types5.default.string.isRequired
} : void 0;

// ../../node_modules/@mui/x-tree-view/esm/TreeItemLabelInput/TreeItemLabelInput.js
var TreeItemLabelInput = styled_default("input", {
  name: "MuiTreeItem",
  slot: "LabelInput"
})(({
  theme
}) => _extends({}, theme.typography.body1, {
  width: "100%",
  backgroundColor: (theme.vars || theme).palette.background.paper,
  borderRadius: theme.shape.borderRadius,
  border: "none",
  padding: "0 2px",
  boxSizing: "border-box",
  "&:focus": {
    outline: `1px solid ${(theme.vars || theme).palette.primary.main}`
  }
}));

// ../../node_modules/@mui/x-tree-view/esm/TreeItem/TreeItem.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var _excluded4 = ["visible"];
var _excluded22 = ["id", "itemId", "label", "disabled", "disableSelection", "children", "slots", "slotProps", "classes"];
var useThemeProps3 = createUseThemeProps("MuiTreeItem");
var TreeItemRoot = styled_default("li", {
  name: "MuiTreeItem",
  slot: "Root"
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  outline: 0
});
var TreeItemContent = styled_default("div", {
  name: "MuiTreeItem",
  slot: "Content",
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "status"
})(({
  theme
}) => ({
  padding: theme.spacing(0.5, 1),
  paddingLeft: `calc(${theme.spacing(1)} + var(--TreeView-itemChildrenIndentation) * var(--TreeView-itemDepth))`,
  borderRadius: theme.shape.borderRadius,
  width: "100%",
  boxSizing: "border-box",
  // prevent width + padding to overflow
  position: "relative",
  display: "flex",
  alignItems: "center",
  gap: theme.spacing(1),
  cursor: "pointer",
  WebkitTapHighlightColor: "transparent",
  "&:hover": {
    backgroundColor: (theme.vars || theme).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  "&[data-disabled]": {
    opacity: (theme.vars || theme).palette.action.disabledOpacity,
    backgroundColor: "transparent",
    cursor: "auto"
  },
  "&[data-focused]": {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  "&[data-selected]": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
      }
    }
  },
  "&[data-selected][data-focused]": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
  }
}));
var TreeItemLabel = styled_default("div", {
  name: "MuiTreeItem",
  slot: "Label",
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "editable"
})(({
  theme
}) => _extends({
  width: "100%",
  boxSizing: "border-box",
  // prevent width + padding to overflow
  // fixes overflow - see https://github.com/mui/material-ui/issues/27372
  minWidth: 0,
  position: "relative",
  overflow: "hidden"
}, theme.typography.body1, {
  variants: [{
    props: ({
      editable
    }) => editable,
    style: {
      paddingLeft: "2px"
    }
  }]
}));
var TreeItemIconContainer = styled_default("div", {
  name: "MuiTreeItem",
  slot: "IconContainer"
})({
  width: 16,
  display: "flex",
  flexShrink: 0,
  justifyContent: "center",
  position: "relative",
  cursor: "inherit",
  "& svg": {
    fontSize: 18
  }
});
var TreeItemGroupTransition = styled_default(Collapse_default, {
  name: "MuiTreeItem",
  slot: "GroupTransition",
  overridesResolver: (props, styles) => styles.groupTransition
})({
  margin: 0,
  padding: 0
});
var TreeItemErrorContainer = styled_default("div", {
  name: "MuiTreeItem",
  slot: "ErrorIcon"
})({
  position: "absolute",
  right: -3,
  width: 7,
  height: 7,
  borderRadius: "50%",
  backgroundColor: "red"
});
var TreeItemLoadingContainer = styled_default(CircularProgress_default, {
  name: "MuiTreeItem",
  slot: "LoadingIcon"
})({
  color: "text.primary"
});
var TreeItemCheckbox = styled_default(React28.forwardRef((props, ref) => {
  const {
    visible
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
  if (!visible) {
    return null;
  }
  return (0, import_jsx_runtime10.jsx)(Checkbox_default, _extends({}, other, {
    ref
  }));
}), {
  name: "MuiTreeItem",
  slot: "Checkbox"
})({
  padding: 0
});
if (true) TreeItemCheckbox.displayName = "TreeItemCheckbox";
var useUtilityClasses2 = (classesProp) => {
  const {
    classes: classesFromTreeView
  } = useTreeViewStyleContext();
  const classes = _extends({}, classesProp, {
    root: clsx_default(classesProp?.root, classesFromTreeView.root),
    content: clsx_default(classesProp?.content, classesFromTreeView.itemContent),
    iconContainer: clsx_default(classesProp?.iconContainer, classesFromTreeView.itemIconContainer),
    checkbox: clsx_default(classesProp?.checkbox, classesFromTreeView.itemCheckbox),
    label: clsx_default(classesProp?.label, classesFromTreeView.itemLabel),
    groupTransition: clsx_default(classesProp?.groupTransition, classesFromTreeView.itemGroupTransition),
    labelInput: clsx_default(classesProp?.labelInput, classesFromTreeView.itemLabelInput),
    dragAndDropOverlay: clsx_default(classesProp?.dragAndDropOverlay, classesFromTreeView.itemDragAndDropOverlay),
    errorIcon: clsx_default(classesProp?.errorIcon, classesFromTreeView.itemErrorIcon),
    loadingIcon: clsx_default(classesProp?.loadingIcon, classesFromTreeView.itemLoadingIcon)
  });
  const slots = {
    root: ["root"],
    content: ["content"],
    iconContainer: ["iconContainer"],
    checkbox: ["checkbox"],
    label: ["label"],
    groupTransition: ["groupTransition"],
    labelInput: ["labelInput"],
    dragAndDropOverlay: ["dragAndDropOverlay"],
    errorIcon: ["errorIcon"],
    loadingIcon: ["loadingIcon"],
    expanded: ["expanded"],
    editing: ["editing"],
    editable: ["editable"],
    selected: ["selected"],
    focused: ["focused"],
    disabled: ["disabled"]
  };
  return composeClasses(slots, getTreeItemUtilityClass, classes);
};
var TreeItem = React28.forwardRef(function TreeItem2(inProps, forwardedRef) {
  const props = useThemeProps3({
    props: inProps,
    name: "MuiTreeItem"
  });
  const {
    id,
    itemId,
    label,
    disabled,
    disableSelection,
    children,
    slots = {},
    slotProps = {},
    classes: classesProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded22);
  const {
    getContextProviderProps,
    getRootProps,
    getContentProps,
    getIconContainerProps,
    getCheckboxProps,
    getLabelProps,
    getGroupTransitionProps,
    getLabelInputProps,
    getDragAndDropOverlayProps,
    getErrorContainerProps,
    getLoadingContainerProps,
    status
  } = useTreeItem({
    id,
    itemId,
    children,
    label,
    disabled,
    disableSelection
  });
  const classes = useUtilityClasses2(classesProp);
  const Root = slots.root ?? TreeItemRoot;
  const rootProps = useSlotProps_default({
    elementType: Root,
    getSlotProps: getRootProps,
    externalForwardedProps: other,
    externalSlotProps: slotProps.root,
    additionalProps: {
      ref: forwardedRef
    },
    ownerState: {},
    className: classes.root
  });
  const Content = slots.content ?? TreeItemContent;
  const contentProps = useSlotProps_default({
    elementType: Content,
    getSlotProps: getContentProps,
    externalSlotProps: slotProps.content,
    ownerState: {},
    className: clsx_default(classes.content, status.expanded && classes.expanded, status.selected && classes.selected, status.focused && classes.focused, status.disabled && classes.disabled, status.editing && classes.editing, status.editable && classes.editable)
  });
  const IconContainer = slots.iconContainer ?? TreeItemIconContainer;
  const iconContainerProps = useSlotProps_default({
    elementType: IconContainer,
    getSlotProps: getIconContainerProps,
    externalSlotProps: slotProps.iconContainer,
    ownerState: {},
    className: classes.iconContainer
  });
  const Label = slots.label ?? TreeItemLabel;
  const labelProps = useSlotProps_default({
    elementType: Label,
    getSlotProps: getLabelProps,
    externalSlotProps: slotProps.label,
    ownerState: {},
    className: classes.label
  });
  const Checkbox = slots.checkbox ?? TreeItemCheckbox;
  const checkboxProps = useSlotProps_default({
    elementType: Checkbox,
    getSlotProps: getCheckboxProps,
    externalSlotProps: slotProps.checkbox,
    ownerState: {},
    className: classes.checkbox
  });
  const GroupTransition = slots.groupTransition ?? void 0;
  const groupTransitionProps = useSlotProps_default({
    elementType: GroupTransition,
    getSlotProps: getGroupTransitionProps,
    externalSlotProps: slotProps.groupTransition,
    ownerState: {},
    className: classes.groupTransition
  });
  const LabelInput = slots.labelInput ?? TreeItemLabelInput;
  const labelInputProps = useSlotProps_default({
    elementType: LabelInput,
    getSlotProps: getLabelInputProps,
    externalSlotProps: slotProps.labelInput,
    ownerState: {},
    className: classes.labelInput
  });
  const DragAndDropOverlay = slots.dragAndDropOverlay ?? TreeItemDragAndDropOverlay;
  const dragAndDropOverlayProps = useSlotProps_default({
    elementType: DragAndDropOverlay,
    getSlotProps: getDragAndDropOverlayProps,
    externalSlotProps: slotProps.dragAndDropOverlay,
    ownerState: {},
    className: classes.dragAndDropOverlay
  });
  const ErrorIcon = slots.errorIcon ?? TreeItemErrorContainer;
  const errorContainerProps = useSlotProps_default({
    elementType: ErrorIcon,
    getSlotProps: getErrorContainerProps,
    externalSlotProps: slotProps.errorIcon,
    ownerState: {},
    className: classes.errorIcon
  });
  const LoadingIcon = slots.loadingIcon ?? TreeItemLoadingContainer;
  const loadingContainerProps = useSlotProps_default({
    elementType: LoadingIcon,
    getSlotProps: getLoadingContainerProps,
    externalSlotProps: slotProps.loadingIcon,
    ownerState: {},
    className: classes.loadingIcon
  });
  return (0, import_jsx_runtime10.jsx)(TreeItemProvider, _extends({}, getContextProviderProps(), {
    children: (0, import_jsx_runtime10.jsxs)(Root, _extends({}, rootProps, {
      children: [(0, import_jsx_runtime10.jsxs)(Content, _extends({}, contentProps, {
        children: [(0, import_jsx_runtime10.jsxs)(IconContainer, _extends({}, iconContainerProps, {
          children: [status.error && (0, import_jsx_runtime10.jsx)(ErrorIcon, _extends({}, errorContainerProps)), status.loading ? (0, import_jsx_runtime10.jsx)(LoadingIcon, _extends({}, loadingContainerProps)) : (0, import_jsx_runtime10.jsx)(TreeItemIcon, {
            status,
            slots,
            slotProps
          })]
        })), (0, import_jsx_runtime10.jsx)(Checkbox, _extends({}, checkboxProps)), status.editing ? (0, import_jsx_runtime10.jsx)(LabelInput, _extends({}, labelInputProps)) : (0, import_jsx_runtime10.jsx)(Label, _extends({}, labelProps)), (0, import_jsx_runtime10.jsx)(DragAndDropOverlay, _extends({}, dragAndDropOverlayProps))]
      })), children && (0, import_jsx_runtime10.jsx)(TreeItemGroupTransition, _extends({
        as: GroupTransition
      }, groupTransitionProps))]
    }))
  }));
});
if (true) TreeItem.displayName = "TreeItem";
true ? TreeItem.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types6.default.any,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types6.default.object,
  className: import_prop_types6.default.string,
  /**
   * If `true`, the item is disabled.
   * @default false
   */
  disabled: import_prop_types6.default.bool,
  /**
   * If `true`, the item cannot be selected.
   * @default false
   */
  disableSelection: import_prop_types6.default.bool,
  /**
   * The id attribute of the item. If not provided, it will be generated.
   */
  id: import_prop_types6.default.string,
  /**
   * The id of the item.
   * Must be unique.
   */
  itemId: import_prop_types6.default.string.isRequired,
  /**
   * The label of the item.
   */
  label: import_prop_types6.default.node,
  /**
   * Callback fired when the item root is blurred.
   */
  onBlur: import_prop_types6.default.func,
  /**
   * This prop isn't supported.
   * Use the `onItemFocus` callback on the tree if you need to monitor an item's focus.
   */
  onFocus: unsupportedProp,
  /**
   * Callback fired when a key is pressed on the keyboard and the tree is in focus.
   */
  onKeyDown: import_prop_types6.default.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types6.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types6.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types6.default.oneOfType([import_prop_types6.default.arrayOf(import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object, import_prop_types6.default.bool])), import_prop_types6.default.func, import_prop_types6.default.object])
} : void 0;

// ../../node_modules/@mui/x-tree-view/esm/internals/components/RichTreeViewItems.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var _excluded5 = ["ownerState"];
var RichTreeViewItemsContext = React29.createContext(null);
if (true) RichTreeViewItemsContext.displayName = "RichTreeViewItemsContext";
var EMPTY_ARRAY = [];
var selectorNoChildren = () => EMPTY_ARRAY;
var selectorChildrenIdsNull = (state) => itemsSelectors.itemOrderedChildrenIds(state, null);
var WrappedTreeItem = React29.memo(function WrappedTreeItem2({
  itemSlot,
  itemSlotProps,
  itemId,
  skipChildren
}) {
  const renderItemForRichTreeView = React29.useContext(RichTreeViewItemsContext);
  const {
    store
  } = useTreeViewContext();
  const itemMeta = useStore(store, itemsSelectors.itemMeta, itemId);
  const children = useStore(store, skipChildren ? selectorNoChildren : itemsSelectors.itemOrderedChildrenIds, itemId);
  const Item = itemSlot ?? TreeItem;
  const _useSlotProps = useSlotProps_default({
    elementType: Item,
    externalSlotProps: itemSlotProps,
    additionalProps: {
      label: itemMeta?.label,
      id: itemMeta?.idAttribute,
      itemId
    },
    ownerState: {
      itemId,
      label: itemMeta?.label
    }
  }), itemProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded5);
  return (0, import_jsx_runtime11.jsx)(Item, _extends({}, itemProps, {
    children: children?.map(renderItemForRichTreeView)
  }));
}, fastObjectShallowCompare);
if (true) WrappedTreeItem.displayName = "WrappedTreeItem";
function RichTreeViewItems(props) {
  const {
    slots,
    slotProps
  } = props;
  const {
    store
  } = useTreeViewContext();
  const itemSlot = slots?.item;
  const itemSlotProps = slotProps?.item;
  const domStructure = useStore(store, itemsSelectors.domStructure);
  const items = useStore(store, domStructure === "flat" ? expansionSelectors.flatList : selectorChildrenIdsNull);
  const skipChildren = domStructure === "flat";
  const renderItem = React29.useCallback((itemId) => {
    return (0, import_jsx_runtime11.jsx)(WrappedTreeItem, {
      itemSlot,
      itemSlotProps,
      itemId,
      skipChildren
    }, itemId);
  }, [itemSlot, itemSlotProps, skipChildren]);
  return (0, import_jsx_runtime11.jsx)(RichTreeViewItemsContext.Provider, {
    value: renderItem,
    children: items.map(renderItem)
  });
}

// ../../node_modules/@mui/x-tree-view/esm/RichTreeView/RichTreeView.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var _excluded6 = ["slots", "slotProps"];
var useThemeProps4 = createUseThemeProps("MuiRichTreeView");
var useUtilityClasses3 = (ownerState) => {
  const {
    classes
  } = ownerState;
  return React30.useMemo(() => {
    const slots = {
      root: ["root"],
      item: ["item"],
      itemContent: ["itemContent"],
      itemGroupTransition: ["itemGroupTransition"],
      itemIconContainer: ["itemIconContainer"],
      itemLabel: ["itemLabel"],
      itemLabelInput: ["itemLabelInput"],
      itemCheckbox: ["itemCheckbox"]
      // itemDragAndDropOverlay: ['itemDragAndDropOverlay'], => feature not available on this component
      // itemErrorIcon: ['itemErrorIcon'], => feature not available on this component
    };
    return composeClasses(slots, getRichTreeViewUtilityClass, classes);
  }, [classes]);
};
var RichTreeViewRoot = styled_default("ul", {
  name: "MuiRichTreeView",
  slot: "Root"
})({
  padding: 0,
  margin: 0,
  listStyle: "none",
  outline: 0,
  position: "relative"
});
var RichTreeView = React30.forwardRef(function RichTreeView2(inProps, ref) {
  const props = useThemeProps4({
    props: inProps,
    name: "MuiRichTreeView"
  });
  const {
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
  if (true) {
    if (props.children != null) {
      warnOnce(["MUI X: The Rich Tree View component does not support JSX children.", "If you want to add items, you need to use the `items` prop.", "Check the documentation for more details: https://mui.com/x/react-tree-view/rich-tree-view/items/."]);
    }
  }
  const {
    getRootProps,
    contextValue
  } = useTreeView({
    plugins: RICH_TREE_VIEW_PLUGINS,
    rootRef: ref,
    props: other
  });
  const isLoading = useStore(contextValue.store, lazyLoadingSelectors.isItemLoading, null);
  const error = useStore(contextValue.store, lazyLoadingSelectors.itemError, null);
  const classes = useUtilityClasses3(props);
  const Root = slots?.root ?? RichTreeViewRoot;
  const rootProps = useSlotProps_default({
    elementType: Root,
    externalSlotProps: slotProps?.root,
    className: classes.root,
    getSlotProps: getRootProps,
    ownerState: props
  });
  if (isLoading) {
    return (0, import_jsx_runtime12.jsx)(Typography_default, {
      children: "Loading..."
    });
  }
  if (error) {
    return (0, import_jsx_runtime12.jsx)(Alert_default, {
      severity: "error",
      children: error.message
    });
  }
  return (0, import_jsx_runtime12.jsx)(TreeViewProvider, {
    contextValue,
    classes,
    slots,
    slotProps,
    children: (0, import_jsx_runtime12.jsx)(Root, _extends({}, rootProps, {
      children: (0, import_jsx_runtime12.jsx)(RichTreeViewItems, {
        slots,
        slotProps
      })
    }))
  });
});
if (true) RichTreeView.displayName = "RichTreeView";
true ? RichTreeView.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The ref object that allows Tree View manipulation. Can be instantiated with `useRichTreeViewApiRef()`.
   */
  apiRef: import_prop_types7.default.shape({
    current: import_prop_types7.default.shape({
      focusItem: import_prop_types7.default.func,
      getItem: import_prop_types7.default.func,
      getItemDOMElement: import_prop_types7.default.func,
      getItemOrderedChildrenIds: import_prop_types7.default.func,
      getItemTree: import_prop_types7.default.func,
      getParentId: import_prop_types7.default.func,
      isItemExpanded: import_prop_types7.default.func,
      setEditedItem: import_prop_types7.default.func,
      setIsItemDisabled: import_prop_types7.default.func,
      setItemExpansion: import_prop_types7.default.func,
      setItemSelection: import_prop_types7.default.func,
      updateItemLabel: import_prop_types7.default.func
    })
  }),
  /**
   * Whether the Tree View renders a checkbox at the left of its label that allows selecting it.
   * @default false
   */
  checkboxSelection: import_prop_types7.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types7.default.object,
  className: import_prop_types7.default.string,
  /**
   * Expanded item ids.
   * Used when the item's expansion is not controlled.
   * @default []
   */
  defaultExpandedItems: import_prop_types7.default.arrayOf(import_prop_types7.default.string),
  /**
   * Selected item ids. (Uncontrolled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   * @default []
   */
  defaultSelectedItems: import_prop_types7.default.any,
  /**
   * Whether the items should be focusable when disabled.
   * @default false
   */
  disabledItemsFocusable: import_prop_types7.default.bool,
  /**
   * Whether selection is disabled.
   * @default false
   */
  disableSelection: import_prop_types7.default.bool,
  /**
   * Expanded item ids.
   * Used when the item's expansion is controlled.
   */
  expandedItems: import_prop_types7.default.arrayOf(import_prop_types7.default.string),
  /**
   * The slot that triggers the item's expansion when clicked.
   * @default 'content'
   */
  expansionTrigger: import_prop_types7.default.oneOf(["content", "iconContainer"]),
  /**
   * Used to determine the children of a given item.
   *
   * @template R
   * @param {R} item The item to check.
   * @returns {R[]} The children of the item.
   * @default (item) => item.children
   */
  getItemChildren: import_prop_types7.default.func,
  /**
   * Used to determine the id of a given item.
   *
   * @template R
   * @param {R} item The item to check.
   * @returns {TreeViewItemId} The id of the item.
   * @default (item) => item.id
   */
  getItemId: import_prop_types7.default.func,
  /**
   * Used to determine the string label for a given item.
   *
   * @template R
   * @param {R} item The item to check.
   * @returns {string} The label of the item.
   * @default (item) => item.label
   */
  getItemLabel: import_prop_types7.default.func,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types7.default.string,
  /**
   * Used to determine if a given item should be disabled.
   * @template R
   * @param {R} item The item to check.
   * @returns {boolean} `true` if the item should be disabled.
   */
  isItemDisabled: import_prop_types7.default.func,
  /**
   * Determine if a given item can be edited.
   * @template R
   * @param {R} item The item to check.
   * @returns {boolean} `true` if the item can be edited.
   * @default () => false
   */
  isItemEditable: import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.bool]),
  /**
   * Used to determine if a given item should have selection disabled.
   * @template R
   * @param {R} item The item to check.
   * @returns {boolean} `true` if the item should have selection disabled.
   */
  isItemSelectionDisabled: import_prop_types7.default.func,
  /**
   * Horizontal indentation between an item and its children.
   * Examples: 24, "24px", "2rem", "2em".
   * @default 12px
   */
  itemChildrenIndentation: import_prop_types7.default.oneOfType([import_prop_types7.default.number, import_prop_types7.default.string]),
  items: import_prop_types7.default.array.isRequired,
  /**
   * Whether multiple items can be selected.
   * @default false
   */
  multiSelect: import_prop_types7.default.bool,
  /**
   * Callback fired when Tree Items are expanded/collapsed.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemExpansion()` method.
   * @param {TreeViewItemId[]} itemIds The ids of the expanded items.
   */
  onExpandedItemsChange: import_prop_types7.default.func,
  /**
   * Callback fired when the `content` slot of a given Tree Item is clicked.
   * @param {React.MouseEvent} event The DOM event that triggered the change.
   * @param {TreeViewItemId} itemId The id of the focused item.
   */
  onItemClick: import_prop_types7.default.func,
  /**
   * Callback fired when a Tree Item is expanded or collapsed.
   * @param {React.SyntheticEvent | null} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemExpansion()` method.
   * @param {TreeViewItemId} itemId The itemId of the modified item.
   * @param {boolean} isExpanded `true` if the item has just been expanded, `false` if it has just been collapsed.
   */
  onItemExpansionToggle: import_prop_types7.default.func,
  /**
   * Callback fired when a given Tree Item is focused.
   * @param {React.SyntheticEvent | null} event The DOM event that triggered the change. **Warning**: This is a generic event not a focus event.
   * @param {TreeViewItemId} itemId The id of the focused item.
   */
  onItemFocus: import_prop_types7.default.func,
  /**
   * Callback fired when the label of an item changes.
   * @param {TreeViewItemId} itemId The id of the item that was edited.
   * @param {string} newLabel The new label of the items.
   */
  onItemLabelChange: import_prop_types7.default.func,
  /**
   * Callback fired when a Tree Item is selected or deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemSelection()` method.
   * @param {TreeViewItemId} itemId The itemId of the modified item.
   * @param {boolean} isSelected `true` if the item has just been selected, `false` if it has just been deselected.
   */
  onItemSelectionToggle: import_prop_types7.default.func,
  /**
   * Callback fired when Tree Items are selected/deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemSelection()` method.
   * @param {TreeViewItemId[] | TreeViewItemId} itemIds The ids of the selected items.
   * When `multiSelect` is `true`, this is an array of strings; when false (default) a string.
   */
  onSelectedItemsChange: import_prop_types7.default.func,
  /**
   * Selected item ids. (Controlled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   */
  selectedItems: import_prop_types7.default.any,
  /**
   * When `selectionPropagation.descendants` is set to `true`.
   *
   * - Selecting a parent selects all its descendants automatically.
   * - Deselecting a parent deselects all its descendants automatically.
   *
   * When `selectionPropagation.parents` is set to `true`.
   *
   * - Selecting all the descendants of a parent selects the parent automatically.
   * - Deselecting a descendant of a selected parent deselects the parent automatically.
   *
   * Only works when `multiSelect` is `true`.
   * On the <SimpleTreeView />, only the expanded items are considered (since the collapsed item are not passed to the Tree View component at all)
   *
   * @default { parents: false, descendants: false }
   */
  selectionPropagation: import_prop_types7.default.shape({
    descendants: import_prop_types7.default.bool,
    parents: import_prop_types7.default.bool
  }),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types7.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types7.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types7.default.oneOfType([import_prop_types7.default.arrayOf(import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object, import_prop_types7.default.bool])), import_prop_types7.default.func, import_prop_types7.default.object])
} : void 0;

// ../../node_modules/@mui/x-tree-view/esm/internals/hooks/useInstanceEventHandler.js
var React31 = __toESM(require_react(), 1);

// ../../node_modules/@mui/x-tree-view/esm/internals/utils/cleanupTracking/TimerBasedCleanupTracking.js
var CLEANUP_TIMER_LOOP_MILLIS = 1e3;
var TimerBasedCleanupTracking = class {
  timeouts = /* @__PURE__ */ (() => /* @__PURE__ */ new Map())();
  cleanupTimeout = /* @__PURE__ */ (() => CLEANUP_TIMER_LOOP_MILLIS)();
  constructor(timeout = CLEANUP_TIMER_LOOP_MILLIS) {
    this.cleanupTimeout = timeout;
  }
  register(object, unsubscribe, unregisterToken) {
    if (!this.timeouts) {
      this.timeouts = /* @__PURE__ */ new Map();
    }
    const timeout = setTimeout(() => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
      this.timeouts.delete(unregisterToken.cleanupToken);
    }, this.cleanupTimeout);
    this.timeouts.set(unregisterToken.cleanupToken, timeout);
  }
  unregister(unregisterToken) {
    const timeout = this.timeouts.get(unregisterToken.cleanupToken);
    if (timeout) {
      this.timeouts.delete(unregisterToken.cleanupToken);
      clearTimeout(timeout);
    }
  }
  reset() {
    if (this.timeouts) {
      this.timeouts.forEach((value, key) => {
        this.unregister({
          cleanupToken: key
        });
      });
      this.timeouts = void 0;
    }
  }
};

// ../../node_modules/@mui/x-tree-view/esm/internals/utils/cleanupTracking/FinalizationRegistryBasedCleanupTracking.js
var FinalizationRegistryBasedCleanupTracking = class {
  registry = (() => new FinalizationRegistry((unsubscribe) => {
    if (typeof unsubscribe === "function") {
      unsubscribe();
    }
  }))();
  register(object, unsubscribe, unregisterToken) {
    this.registry.register(object, unsubscribe, unregisterToken);
  }
  unregister(unregisterToken) {
    this.registry.unregister(unregisterToken);
  }
  reset() {
  }
};

// ../../node_modules/@mui/x-tree-view/esm/internals/hooks/useInstanceEventHandler.js
var ObjectToBeRetainedByReact = class {
};
function createUseInstanceEventHandler(registryContainer2) {
  let cleanupTokensCounter = 0;
  return function useInstanceEventHandler2(instance, eventName, handler) {
    if (registryContainer2.registry === null) {
      registryContainer2.registry = typeof FinalizationRegistry !== "undefined" ? new FinalizationRegistryBasedCleanupTracking() : new TimerBasedCleanupTracking();
    }
    const [objectRetainedByReact] = React31.useState(new ObjectToBeRetainedByReact());
    const subscription = React31.useRef(null);
    const handlerRef = React31.useRef(void 0);
    handlerRef.current = handler;
    const cleanupTokenRef = React31.useRef(null);
    if (!subscription.current && handlerRef.current) {
      const enhancedHandler = (params, event) => {
        if (!event.defaultMuiPrevented) {
          handlerRef.current?.(params, event);
        }
      };
      subscription.current = instance.$$subscribeEvent(eventName, enhancedHandler);
      cleanupTokensCounter += 1;
      cleanupTokenRef.current = {
        cleanupToken: cleanupTokensCounter
      };
      registryContainer2.registry.register(
        objectRetainedByReact,
        // The callback below will be called once this reference stops being retained
        () => {
          subscription.current?.();
          subscription.current = null;
          cleanupTokenRef.current = null;
        },
        cleanupTokenRef.current
      );
    } else if (!handlerRef.current && subscription.current) {
      subscription.current();
      subscription.current = null;
      if (cleanupTokenRef.current) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
    }
    React31.useEffect(() => {
      if (!subscription.current && handlerRef.current) {
        const enhancedHandler = (params, event) => {
          if (!event.defaultMuiPrevented) {
            handlerRef.current?.(params, event);
          }
        };
        subscription.current = instance.$$subscribeEvent(eventName, enhancedHandler);
      }
      if (cleanupTokenRef.current && registryContainer2.registry) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
      return () => {
        subscription.current?.();
        subscription.current = null;
      };
    }, [instance, eventName]);
  };
}
var registryContainer = {
  registry: null
};
var unstable_resetCleanupTracking = () => {
  registryContainer.registry?.reset();
  registryContainer.registry = null;
};
var useInstanceEventHandler = createUseInstanceEventHandler(registryContainer);

// ../../node_modules/@mui/x-tree-view/esm/hooks/useTreeItemModel.js
var useTreeItemModel = (itemId) => {
  const {
    store
  } = useTreeViewContext();
  return useStore(store, itemsSelectors.itemModel, itemId);
};

// ../../node_modules/@mui/x-tree-view/esm/hooks/useApplyPropagationToSelectedItemsOnMount.js
var defaultGetItemId = (item) => item.id;
var defaultGetItemChildren = (item) => item.children;
function useApplyPropagationToSelectedItemsOnMount(parameters) {
  const {
    items: itemsParam,
    getItemId = defaultGetItemId,
    getItemChildren = defaultGetItemChildren,
    selectedItems,
    selectionPropagation
  } = parameters;
  return useRefWithInit(() => {
    const lookup = getLookupFromArray(selectedItems);
    function walk(items, isParentSelected) {
      for (const item of items) {
        const itemId = getItemId(item);
        let isSelected = lookup[itemId];
        if (!isSelected && selectionPropagation.descendants && isParentSelected) {
          lookup[itemId] = true;
          isSelected = true;
        }
        const children = getItemChildren(item) ?? [];
        if (children.length > 0) {
          walk(children, isSelected);
          if (!isSelected && selectionPropagation.parents) {
            const areAllChildrenSelected = children.every((childId) => lookup[getItemId(childId)]);
            if (areAllChildrenSelected) {
              lookup[itemId] = true;
            }
          }
        }
      }
    }
    walk(itemsParam, false);
    return Object.keys(lookup);
  }).current;
}

// ../../node_modules/@mui/x-tree-view/esm/hooks/useTreeViewApiRef.js
var React32 = __toESM(require_react(), 1);
var useTreeViewApiRef = () => React32.useRef(void 0);

// ../../node_modules/@mui/x-tree-view/esm/hooks/useRichTreeViewApiRef.js
var React33 = __toESM(require_react(), 1);
function useRichTreeViewApiRef() {
  return React33.useRef(void 0);
}

// ../../node_modules/@mui/x-tree-view/esm/hooks/useSimpleTreeViewApiRef.js
var React34 = __toESM(require_react(), 1);
function useSimpleTreeViewApiRef() {
  return React34.useRef(void 0);
}
export {
  RICH_TREE_VIEW_PLUGINS,
  RichTreeView,
  RichTreeViewRoot,
  SimpleTreeView,
  SimpleTreeViewRoot,
  TreeItem,
  TreeItemCheckbox,
  TreeItemContent,
  TreeItemDragAndDropOverlay,
  TreeItemGroupTransition,
  TreeItemIcon,
  TreeItemIconContainer,
  TreeItemLabel,
  TreeItemLabelInput,
  TreeItemProvider,
  TreeItemRoot,
  TreeViewCollapseIcon,
  TreeViewExpandIcon,
  getRichTreeViewUtilityClass,
  getSimpleTreeViewUtilityClass,
  getTreeItemUtilityClass,
  richTreeViewClasses,
  simpleTreeViewClasses,
  treeItemClasses,
  unstable_resetCleanupTracking,
  useApplyPropagationToSelectedItemsOnMount,
  useRichTreeViewApiRef,
  useSimpleTreeViewApiRef,
  useTreeItem,
  useTreeItemModel,
  useTreeItemUtils,
  useTreeViewApiRef
};
//# sourceMappingURL=@mui_x-tree-view.js.map
